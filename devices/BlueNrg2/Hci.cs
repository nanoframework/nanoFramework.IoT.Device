// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using Iot.Device.BlueNrg2.Aci;
using Iot.Device.BlueNrg2.Aci.Events;

namespace Iot.Device.BlueNrg2
{
    /// <summary>
    /// Class containing all the HCI commands.
    /// </summary>
    public class Hci
    {
        private readonly TransportLayer _transportLayer;

        internal Hci(TransportLayer transportLayer)
        {
            _transportLayer = transportLayer;
        }

        internal void Init()
        {
            _transportLayer.Reset();
        }

        /// <summary>
        /// This is used to terminate an existing connection.
        /// The <see cref="connectionHandle"/> command parameter indicates which connection is
        /// to be disconnected. The <see cref="reason"/> command parameter indicates the reason
        /// for ending the connection. The remote Controller will receive the
        /// <see cref="reason"/> command parameter in the <see cref="EventProcessor.DisconnectionCompleteEvent"/>
        /// event. All synchronous connections on a physical link should be
        /// disconnected before the ACL connection on the same physical connection
        /// is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.6) It is important to leave an 100 ms blank window before sending
        /// any new command (including system hardware reset), since immediately
        /// after <see cref="EventProcessor.DisconnectionCompleteEvent"/> event, system could save
        /// important information in non volatile memory.
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="reason">The reason for ending the connection.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Disconnect(ushort connectionHandle, Reason reason)
        {
            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)reason;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will obtain the values for the version information for
        /// the remote device identified by the <see cref="connectionHandle"/> parameter. The
        /// <see cref="connectionHandle"/> must be a <see cref="connectionHandle"/> for an ACL or LE
        /// connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.23)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's version
        /// information to get.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <seealso cref="EventProcessor.ReadRemoteVersionInformationCompleteEvent"/>
        public BleStatus ReadRemoteVersionInformation(ushort connectionHandle)
        {
            var command = BitConverter.GetBytes(connectionHandle);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which events are
        /// generated by the HCI for the Host.  If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// For an LE Controller, the LE Meta Event bit in the <see cref="eventMask"/> shall
        /// enable or disable all LE events in the LE Meta Event (see Section
        /// 7.7.65). The Host has to deal with each event that occurs. The event
        /// mask allows the Host to control how much it is interrupted. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)
        /// </summary>
        /// <param name="eventMask">Event mask. Default: 0x00001FFFFFFFFFFF</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus SetEventMask(HciEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will reset the Link Layer on an LE Controller.  The
        /// Reset command shall not affect the used HCI transport layer since the
        /// HCI transport layers may have reset mechanisms of their own. After the
        /// reset is completed, the current operational state will be lost, the
        /// Controller will enter standby mode and the Controller will
        /// automatically revert to the default values for the parameters for
        /// which default values are defined in the specification. Note: The Reset
        /// command will not necessarily perform a hardware reset. This is
        /// implementation defined.  The Host shall not send additional HCI
        /// commands before the Command Complete event related to the Reset
        /// command has been received. (See Bluetooth Specification v.4.1, Vol. 2,
        /// Part E, 7.3.2)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Reset()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x003,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the <see cref="transmitPowerLevel"/> parameter
        /// for the specified <see cref="connectionHandle"/>. The <see cref="connectionHandle"/> shall be a
        /// <see cref="connectionHandle"/> for an ACL connection. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.3.35)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's Transmit Power
        /// Level setting to read.</param>
        /// <param name="type">Current or maximum transmit power level.</param>
        /// <param name="transmitPowerLevel">Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadTransmitPowerLevel(ushort connectionHandle, TransmitPowerLevelType type, out sbyte transmitPowerLevel)
        {
            transmitPowerLevel = 0;

            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)type;
            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x02d,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            transmitPowerLevel = (sbyte)response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the version information for the
        /// local Controller. The HCI Version information defines the version
        /// information of the HCI layer. The LMP/PAL Version information defines
        /// the version of the LMP or PAL. The <see cref="manufacturerName"/> information
        /// indicates the manufacturer of the local device. The HCI Revision and
        /// LMP/PAL Subversion are implementation dependent. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.4.1)
        /// </summary>
        /// <param name="version">See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="revision">Revision of the Current HCI in the BR/EDR Controller.</param>
        /// <param name="palVersion">Version of the Current LMP or PAL in the Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="manufacturerName">Manufacturer Name of the BR/EDR Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="palSubVersion">Subversion of the Current LMP or PAL in the Controller. This value is implementation dependent.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalVersionInformation(
            out byte version,
            out ushort revision,
            out byte palVersion,
            out ushort manufacturerName,
            out ushort palSubVersion)
        {
            version = 0;
            revision = 0;
            palVersion = 0;
            manufacturerName = 0;
            palSubVersion = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x001,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            version = response[1];
            revision = BitConverter.ToUInt16(response, 2);
            palVersion = response[4];
            manufacturerName = BitConverter.ToUInt16(response, 5);
            palSubVersion = BitConverter.ToUInt16(response, 7);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the list of HCI commands supported for the local
        /// Controller. This command shall return the <see cref="supportedCommands"/> 
        /// configuration parameter. It is implied that if a command is listed as
        /// supported, the feature underlying that command is also supported. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)
        /// </summary>
        /// <param name="supportedCommands">Bit mask for each HCI Command. If a bit is 1,
        /// the Controller supports the corresponding command and the
        /// features required for the command.Unsupported or undefined
        /// commands shall be set to 0.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="supportedCommands"/> has to have a length of 64.</exception>
        public BleStatus ReadLocalSupportedCommands(out byte[] supportedCommands)
        {
            supportedCommands = null;

            var response = new byte[65];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 65
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            supportedCommands = new byte[64];

            Array.Copy(response, 1, supportedCommands, 0, 64);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests a list of the supported features for the local
        /// Controller. This command will return a list of the LMP features. For
        /// details see Part C, Link Manager Protocol Specification on page 227.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LMP features.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalSupportedFeatures(out ulong features)
        {
            features = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// On an LE Controller, this command shall read the Public Device Address
        /// as defined in [Vol 6] Part B, Section 1.3, Device Address. If this
        /// Controller does not have a Public Device Address, the value
        /// 0x000000000000 shall be returned. On an LE Controller, the public
        /// address shall be the same as the <see cref="address"/>. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.4.6)
        /// </summary>
        /// <param name="address">Bluetooth device address of the device.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="address"/> has to have a length of 6.</exception>
        public BleStatus ReadBluetoothDeviceAddress(out byte[] address)
        {
            address = null;

            var response = new byte[7];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 7
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            address = new byte[6];
            Array.Copy(response, 1, address, 0, 6);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the Received Signal Strength Indication (RSSI)
        /// value from a Controller. For an LE transport, a <see cref="connectionHandle"/> is
        /// used as the Handle command parameter and return parameter. The meaning
        /// of the RSSI metric is an absolute receiver signal strength value in
        /// dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric
        /// shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part
        /// E, 7.5.4)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="rssi">N Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadRssi(ushort connectionHandle, out sbyte rssi)
        {
            rssi = 0;

            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            rssi = (sbyte)response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which LE events are
        /// generated by the HCI for the Host. If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// The Host has to deal with each event that is generated by an LE
        /// Controller. The event mask allows the Host to control which events
        /// will interrupt it. For LE events to be generated, the LE Meta-Event
        /// bit in the Event_Mask shall also be set. If that bit is not set, then
        /// LE events shall not be generated, regardless of how the <see cref="eventMask"/>
        /// is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)
        /// </summary>
        /// <param name="eventMask">LE event mask. Default: 0x000000000000001F.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetEventMask(LeEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to read the maximum size of
        /// the data portion of HCI LE ACL Data Packets sent from the Host to the
        /// Controller. The Host will segment the data transmitted to the
        /// Controller according to these values, so that the HCI Data Packets
        /// will contain data with up to this size. This
        /// command also returns the total number of HCI LE ACL Data Packets that
        /// can be stored in the data buffers of the Controller. This
        /// command must be issued by the Host before it sends
        /// any data to an LE Controller (see Section 4.1.1). If the Controller
        /// returns a length value of zero, the Host shall use the ReadBufferSize
        /// command to determine the size of the data buffers
        /// Note: Both the ReadBufferSize and <see cref="LeReadBufferSize"/> commands may
        /// return buffer length and number of packets parameter values that are
        /// nonzero. The <see cref="packetLength"/> return parameter shall be
        /// used to determine the size of the L2CAP PDU segments contained in ACL
        /// Data Packets, which are transferred from the Host to the Controller to
        /// be broken up into packets by the Link Layer. Both the Host and the
        /// Controller shall support command and event packets, where the data
        /// portion (excluding header) contained in the packets is 255 octets in
        /// size. The <see cref="packetCount"/> return parameter contains
        /// the total number of HCI ACL Data Packets that can be stored in the
        /// data buffers of the Controller. The Host determines how the buffers
        /// are to be divided between different Connection Handles. Note: The
        /// <see cref="packetLength"/> return parameter does not include the
        /// length of the HCI Data Packet header. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.8.2)
        /// </summary>
        /// <param name="packetLength">
        /// 0x0000 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x0001 - 0xFFFF Maximum length (in octets) of the data portion of each HCI ACL Data Packet that the Controller is able to accept.
        /// </param>
        /// <param name="packetCount">
        /// 0x00 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x01 - 0xFF Total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller.
        /// </param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadBufferSize(out ushort packetLength, out byte packetCount)
        {
            packetLength = 0;
            packetCount = 0;

            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 4
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            packetLength = BitConverter.ToUInt16(response, 1);
            packetCount = response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests the list of the supported LE features for the
        /// Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LE features. See Core v4.1, Vol. 6,
        /// Part B, Section 4.6.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadLocalSupportedFeatures(out ulong features)
        {
            features = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used by the Host to set the LE
        /// Random Device Address in the Controller (see [Vol 6] Part B, Section
        /// 1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)
        /// </summary>
        /// <param name="randomAddress">Random device address.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="randomAddress"/> has to be an array of lenght 6.</exception>
        public BleStatus LeSetRandomAddress(byte[] randomAddress)
        {
            if (randomAddress is null || randomAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[6];
            Array.Copy(randomAddress, command, 6);
            var response = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x005,
                CommandParameter = command,
                CommandLength = 6,
                ResponseParameter = response,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return (BleStatus)response[0];
        }

        /// <summary>
        /// This command is used by the Host to set
        /// the advertising parameters. The <see cref="minAdvertisingInterval"/> shall be less
        /// than or equal to the <see cref="maxAdvertisingInterval"/>. The
        /// <see cref="minAdvertisingInterval"/> and <see cref="maxAdvertisingInterval"/> should not be
        /// the same value to enable the Controller to determine the best
        /// advertising interval given other activities. For high duty cycle
        /// directed advertising, i.e. when <see cref="advertisingType"/> is 0x01
        /// (ADV_DIRECT_IND, high duty cycle), the <see cref="minAdvertisingInterval"/> and
        /// <see cref="maxAdvertisingInterval"/> parameters are not used and shall be ignored.
        /// The <see cref="advertisingType"/> is used to determine the packet type that is used
        /// for advertising when advertising is enabled. <see cref="ownAddressType"/>
        /// parameter indicates the type of address being used in the advertising
        /// packets. If <see cref="ownAddressType"/> equals 0x02 or 0x03, the <see cref="peerAddress"/> 
        /// parameter contains the peer's Identity Address and the
        /// <see cref="peerAddressType"/> parameter contains the Peer's Identity Type (i.e.
        /// 0x00 or 0x01). These parameters are used to locate the corresponding
        /// local IRK in the resolving list; this IRK is used to generate the own
        /// address used in the advertisement. If directed advertising is
        /// performed, i.e. when <see cref="advertisingType"/> is set to 0x01 (ADV_DIRECT_IND,
        /// high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then
        /// the <see cref="peerAddressType"/> and <see cref="peerAddress"/> shall be valid. If
        /// <see cref="ownAddressType"/> equals 0x02 or 0x03, the Controller generates the
        /// peer's Resolvable Private Address using the peer's IRK corresponding
        /// to the peer's Identity Address contained in the <see cref="peerAddress"/> parameter
        /// and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the
        /// <see cref="peerAddressType"/> parameter. The <see cref="advertisingChannelMap"/> is a bit
        /// field that indicates the advertising channels that shall be used when
        /// transmitting advertising packets. At least one channel bit shall be
        /// set in the <see cref="advertisingChannelMap"/> parameter. The
        /// <see cref="advertisingFilterPolicy"/> parameter shall be ignored when directed
        /// advertising is enabled. The Host shall not issue this command when
        /// advertising is enabled in the Controller; if it is the Command
        /// Disallowed error code shall be used. If the advertising interval range
        /// provided by the Host (<see cref="minAdvertisingInterval"/>,
        /// <see cref="maxAdvertisingInterval"/>) is outside the advertising interval range
        /// supported by the Controller, then the Controller shall return the
        /// Unsupported Feature or Parameter Value (0x11) error code.
        /// </summary>
        /// <param name="minAdvertisingInterval">Minimum advertising interval for undirected
        /// and low duty cycle directed advertising. Time = N * 0.625 msec.</param>
        /// <param name="maxAdvertisingInterval">Maximum advertising interval. Time = N * 0.625 msec.</param>
        /// <param name="advertisingType">Advertising type.</param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.
        /// </item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local
        ///     IRK from resolving list. If resolving list contains no matching entry,
        ///     use random address from LE_Set_Random_Address.
        /// </item>
        /// </list>
        /// </param>
        /// <param name="peerAddressType">Peer Address type.</param>
        /// <param name="peerAddress"> Public Device Address, Random Device Address, Public
        /// Identity Address or Random (static) Identity Address of the device to
        /// be connected.</param>
        /// <param name="advertisingChannelMap">Advertising channel map. Default: 00000111b
        /// (all channels enabled).</param>
        /// <param name="advertisingFilterPolicy">Advertising filter policy.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="peerAddress"/> needs to be an array of length 6.</exception>
        public BleStatus LeSetAdvertisingParameters(
            ushort minAdvertisingInterval,
            ushort maxAdvertisingInterval,
            AdvertisingType advertisingType,
            AddressType ownAddressType,
            AddressType peerAddressType,
            byte[] peerAddress,
            ChannelMap advertisingChannelMap,
            FilterPolicy advertisingFilterPolicy)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[15];
            BitConverter.GetBytes(minAdvertisingInterval).CopyTo(command, 0);
            BitConverter.GetBytes(maxAdvertisingInterval).CopyTo(command, 2);
            command[4] = (byte)advertisingType;
            command[5] = (byte)ownAddressType;
            command[6] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 7);
            command[13] = (byte)advertisingChannelMap;
            command[14] = (byte)advertisingFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x006,
                CommandParameter = command,
                CommandLength = 15,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeReadAdvertisingChannelTxPower(out sbyte transmitPowerLevel)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This command is used to set the data used in advertising packets that have a data
        /// field. Only the significant part of the <see cref="advertisingData"/> is
        /// transmitted in the advertising packets, as defined in [Vol 3] Part C,
        /// Section 11. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.7)
        /// </summary>
        /// <param name="advertisingDataLength">The number of significant octets in the following data field.</param>
        /// <param name="advertisingData">31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="advertisingData"/> has to be an array of length 31.</exception>
        public BleStatus LeSetAdvertisingData(byte advertisingDataLength, byte[] advertisingData)
        {
            if (advertisingData is null || advertisingData.Length != 31)
                throw new ArgumentException();
            var command = new byte[32];
            command[0] = advertisingDataLength;
            advertisingData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x008,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to provide data used in Scanning Packets that
        /// have a data field. Only the significant part of the <see cref="scanResponseData"/>
        /// is transmitted in the Scanning Packets, as defined in [Vol 3] Part C,
        /// Section 11. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.8)
        /// </summary>
        /// <param name="scanResponseDataLength">The number of significant octets in the
        /// following data field.</param>
        /// <param name="scanResponseData">31 octets of data formatted as defined in [Vol 3]
        /// Part C, Section 11.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="scanResponseData"/> has to be an array of length 31 or less</exception>
        public BleStatus LeSetScanResponseData(byte scanResponseDataLength, byte[] scanResponseData)
        {
            if (scanResponseDataLength > 31)
                throw new ArgumentException();
            var command = new byte[32];
            command[0] = scanResponseDataLength;
            if (scanResponseData is not null)
                scanResponseData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x009,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to request the Controller
        /// to start or stop advertising. The Controller manages the timing of
        /// advertisements as per the advertising parameters given in the
        /// <see cref="LeSetAdvertisingParameters"/> command. The Controller shall continue
        /// advertising until the Host issues an <see cref="LeSetAdvertiseEnable"/> command
        /// with <see cref="enableAdvertising"/> set to false (Advertising is disabled) or until
        /// a connection is created or until the Advertising is timed out due to
        /// high duty cycle Directed Advertising. In these cases, advertising is
        /// then disabled. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.9)
        /// </summary>
        /// <param name="enableAdvertising">Enable/disable advertise. Default is false (disabled).</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetAdvertiseEnable(bool enableAdvertising)
        {
            var command = new byte[1];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00a,
                CommandParameter = command,
                CommandLength = 1,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to set the scan parameters.
        /// The <see cref="ScanType"/> parameter controls the type of scan to perform. The
        /// <see cref="scanInterval"/> and <see cref="scanWindow"/> parameters are recommendations
        /// from the Host on how long (<see cref="scanWindow"/>) and how frequently
        /// (<see cref="scanInterval"/>) the Controller should scan (See [Vol 6] Part B,
        /// Section 4.5.3). The <see cref="scanWindow"/> parameter shall always be set to a
        /// value smaller or equal to the value set for the <see cref="scanInterval"/>
        /// parameter. If they are set to the same value scanning should be run
        /// continuously. The <see cref="ownAddressType"/> parameter determines the address
        /// used (Public or Random Device Address) when performing active scan.
        /// The Host shall not issue this command when scanning is enabled in the
        /// Controller; if it is the Command Disallowed error code shall be used.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.10)
        /// </summary>
        /// <param name="scanType">Passive or active scanning. With active scanning SCAN_REQ packets are sent.</param>
        /// <param name="scanInterval">
        /// This is defined as the time interval from when the Controller started
        /// its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 ms.
        /// </param>
        /// <param name="scanWindow">
        /// The duration of the LE scan. LE_Scan_Window shall be
        /// less than or equal to LE_Scan_Interval. Time = N * 0.625 ms.
        /// </param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.</item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use random address from LE_Set_Random_Address.</item>
        /// </list>
        /// </param>
        /// <param name="scanningFilterPolicy">
        /// <list type="bullet">
        /// <item>
        ///     0x00 Accept all advertisement packets. Directed advertising packets which
        ///     are not addressed for this device shall be ignored.
        /// </item>
        /// <item>
        ///     0x01 Ignore advertisement packets from devices not in the White List Only.
        ///     Directed advertising packets which are not addressed for this device shall be ignored.
        /// </item>
        /// <item>
        ///     0x02 Accept all undirected advertisement packets. Directed advertisement packets where
        ///     initiator address is a RPA and  Directed advertisement packets addressed to this device shall be accepted.
        /// </item>
        /// <item>
        ///     0x03 Accept all undirected advertisement packets from devices that are in the White List.
        ///     Directed advertisement packets where initiator address is RPA and Directed advertisement
        ///     packets addressed to this device shall be accepted.
        /// </item>
        /// </list>
        /// </param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetScanParameters(
            ScanType scanType,
            ushort scanInterval,
            ushort scanWindow,
            AddressType ownAddressType,
            FilterPolicy scanningFilterPolicy)
        {
            var command = new byte[7];
            command[0] = (byte)scanType;
            BitConverter.GetBytes(scanInterval).CopyTo(command, 1);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 3);
            command[5] = (byte)ownAddressType;
            command[6] = (byte)scanningFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00b,
                CommandParameter = command,
                CommandLength = 7,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to start scanning. Scanning is
        /// used to discover advertising devices nearby. The <see cref="filterDuplicates"/>
        /// parameter controls whether the Link Layer shall filter duplicate
        /// advertising reports to the Host, or if the Link Layer should generate
        /// advertising reports for each packet received. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.8.11)
        /// </summary>
        /// <param name="enableAdvertising">Enable/disable scan. Default is 0 (disabled).</param>
        /// <param name="filterDuplicates">Enable/disable duplicate filtering.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetScanEnable(bool enableAdvertising, bool filterDuplicates)
        {
            var command = new byte[2];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            command[1] = (byte)(filterDuplicates ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00c,
                CommandParameter = command,
                CommandLength = 2,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to create a Link Layer
        /// connection to a connectable advertiser. The <see cref="scanWindow"/> and
        /// <see cref="scanWindow"/> parameters are recommendations from the Host on how
        /// long (<see cref="scanWindow"/>) and how frequently (<see cref="scanInterval"/>) the
        /// Controller should scan. The <see cref="scanWindow"/> parameter shall be set to a
        /// value smaller or equal to the value set for the <see cref="scanInterval"/>
        /// parameter. If both are set to the same value, scanning should run
        /// continuously. The <see cref="useWhiteList"/> is used to determine whether
        /// the White List is used. If the White List is not used, the
        /// <see cref="peerAddressType"/> and the <see cref="peerAddress"/> parameters specify the address
        /// type and address of the advertising device to connect to. The Link
        /// Layer shall set the address in the CONNECT_REQ packets to either the
        /// Public Device Address or the Random Device Addressed based on the
        /// <see cref="ownAddressType"/> parameter. The <see cref="minimumConnectionInterval"/> and
        /// <see cref="maximumConnectionInterval"/> parameters define the minimum and maximum allowed
        /// connection interval. The <see cref="minimumConnectionInterval"/> parameter shall not be
        /// greater than the <see cref="maximumConnectionInterval"/> parameter. The <see cref="connectionLatency"/>
        /// parameter defines the maximum allowed connection latency (see [Vol 6]
        /// Part B, Section 4.5.1). The <see cref="supervisionTimeout"/> parameter defines the
        /// link supervision timeout for the connection. The <see cref="supervisionTimeout"/>
        /// in milliseconds shall be larger than (1 + <see cref="connectionLatency"/>) *
        /// <see cref="maximumConnectionInterval"/> * 2, where <see cref="maximumConnectionInterval"/> is given in
        /// milliseconds. (See [Vol 6] Part B, Section 4.5.2). The
        /// <see cref="minimumConnectionEventLength"/> and <see cref="maximumConnectionEventLength"/> parameters are informative
        /// parameters providing the Controller with the expected minimum and
        /// maximum length of the connection events. The <see cref="minimumConnectionEventLength"/>
        /// parameter shall be less than or equal to the <see cref="maximumConnectionEventLength"/>
        /// parameter. The Host shall not issue this command when another
        /// <see cref="LeCreateConnection"/> is pending in the Controller; if this does occur
        /// the Controller shall return the Command Disallowed error code shall be
        /// used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.12)
        /// </summary>
        /// <param name="scanInterval">
        /// This is defined as the time interval from when the
        /// Controller started its last LE scan until it begins the subsequent LE
        /// scan. Time = N * 0.625 ms.
        /// </param>
        /// <param name="scanWindow">
        /// The duration of the LE scan. <see cref="scanWindow"/> shall be
        /// less than or equal to <see cref="scanInterval"/>. Time = N * 0.625 ms.</param>
        /// <param name="useWhiteList">
        /// <list type="bullet">
        /// <item>false: White list is not used to determine which advertiser to connect to. Peer_Address_Type and Peer_Address shall be used.</item>
        /// <item>true: White list is used to determine which advertiser to connect to. Peer_Address_Type and Peer_Address shall be ignored.</item>
        /// </list>
        /// </param>
        /// <param name="peerAddressType">
        /// <list type="bullet">
        /// <item>0x00 Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>0x02 Public Identity Address (Corresponds to Resolved Private Address)</item>
        /// <item>0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</item>
        /// </list>
        /// </param>
        /// <param name="peerAddress">Public Device Address, Random Device Address, Public
        /// Identity Address or Random (static) Identity Address of the
        /// advertising device.</param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.
        /// </item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use random address from <see cref="LeSetRandomAddress"/>.
        /// </item>
        /// </list>
        /// </param>
        /// <param name="minimumConnectionInterval">Minimum value for the connection event interval.
        /// This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 ms.</param>
        /// <param name="maximumConnectionInterval">Maximum value for the connection event interval.
        /// This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 ms.</param>
        /// <param name="connectionLatency">Slave latency for the connection in number of connection events.</param>
        /// <param name="supervisionTimeout">Supervision timeout for the LE Link. It shall be a
        /// multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 ms.</param>
        /// <param name="minimumConnectionEventLength">Information parameter about the minimum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <param name="maximumConnectionEventLength">Information parameter about the maximum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="peerAddress"/> needs to be an array of length 6.</exception>
        public BleStatus LeCreateConnection(
            ushort scanInterval,
            ushort scanWindow,
            bool useWhiteList,
            AddressType peerAddressType,
            byte[] peerAddress,
            AddressType ownAddressType,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionEventLength,
            ushort maximumConnectionEventLength)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[24];
            BitConverter.GetBytes(scanInterval).CopyTo(command, 0);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 2);
            command[4] = (byte)(useWhiteList ? 0x01 : 0x00);
            command[5] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 6);
            command[12] = (byte)ownAddressType;
            BitConverter.GetBytes(minimumConnectionInterval).CopyTo(command, 13);
            BitConverter.GetBytes(maximumConnectionInterval).CopyTo(command, 15);
            BitConverter.GetBytes(connectionLatency).CopyTo(command, 17);
            BitConverter.GetBytes(supervisionTimeout).CopyTo(command, 19);
            BitConverter.GetBytes(minimumConnectionEventLength).CopyTo(command, 21);
            BitConverter.GetBytes(maximumConnectionEventLength).CopyTo(command, 23);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00d,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 24,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to cancel the <see cref="LeCreateConnection"/> command.
        /// This command shall only be issued after the <see cref="LeCreateConnection"/>
        /// command has been issued, a Command Status event has been received for the LE
        /// Create Connection command and before the LE Connection Complete event.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.13)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeCreateConnectionCancel()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00e,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeReadWhitelistSize(out byte whiteListSize)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeClearWhiteList()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x010,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeAddDeviceToWhitelist(AddressType addressType, byte[] address)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRemoveDeviceFromWhitelist(AddressType addressType, byte[] address)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeConnectionUpdate(
            ushort connectionHandle,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionLength,
            ushort maximumConnectionLength)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetHostChannelClassification(byte[] channelMap)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadChannelMap(ushort connectionHandle, byte[] channelMap)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadRemoteUsedFeatures(ushort connectionHandle)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeEncrypt(byte[] key, byte[] plaintextData, out byte[] encryptedData)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRandom(out byte[] randomNumber)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeStartEncryption(ushort connectionHandle, byte[] randomNumber, ushort encryptedDiversifier, byte[] longTermKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeLongTermKeyRequestReply(ushort connectionHandle, byte[] longTermKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeLongTermKeyRequestedNegativeReply(ushort connectionHandle)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadSupportedStates(out byte[] states)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReceiverTest(byte rxFrequency)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeTransmitterTest(byte txFrequency, byte testDataLength, byte packetPayload)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeTestEnd(out ushort numberOfPackets)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetDataLength(ushort connectionHandle, ushort transmissionOctets, ushort transmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadSuggestedDefaultDataLength(out ushort suggestedMaximumTransmissionOctets, out ushort suggestedMaxTransmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeWriteSuggestedDefaultDataLength(ushort suggestedMaximumTransmissionOctets, ushort suggestedMaxTransmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadLocalP256PublicKey()
        {
            throw new NotImplementedException();
        }

        public BleStatus LeGenerateDhKey(byte[] remoteP256PublicKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeAddDeviceToResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, byte[] peerIrk, byte[] localIrk)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRemoveDeviceFromResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeClearResolvingList()
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadResolvingListSize(out byte resolvingListSize)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadPeerResolvableAddress(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, out byte[] peerResolvableAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadLocalResolvableAddress(
            AddressType peerIdentityAddressType,
            byte[] peerIdentityAddress,
            out byte[] localResolvableAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetAddressResolutionEnable(bool enableAddressResolution)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetResolvablePrivateAddressTimeout(ushort rpaTimeout)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadMaximumDataLength(
            out ushort supportedMaximumOctets,
            out ushort supportedMaximumTransmissionTime,
            out ushort supportedMaximumReceivingOctets,
            out ushort supportedMaxReceivingTime)
        {
            throw new NotImplementedException();
        }

        internal void UserEventProcess()
        {
            _transportLayer.UserEventProcess();
        }
    }
}
