// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using Iot.Device.BlueNrg2.Aci;
using Iot.Device.BlueNrg2.Aci.Events;

namespace Iot.Device.BlueNrg2
{
    /// <summary>
    /// Class containing all the HCI commands.
    /// </summary>
    public class Hci
    {
        private readonly TransportLayer _transportLayer;

        internal Hci(TransportLayer transportLayer)
        {
            _transportLayer = transportLayer;
        }

        internal void Init()
        {
            _transportLayer.Reset();
        }

        /// <summary>
        /// This is used to terminate an existing connection.
        /// The <see cref="connectionHandle"/> command parameter indicates which connection is
        /// to be disconnected. The <see cref="reason"/> command parameter indicates the reason
        /// for ending the connection. The remote Controller will receive the
        /// <see cref="reason"/> command parameter in the <see cref="EventProcessor.DisconnectionCompleteEvent"/>
        /// event. All synchronous connections on a physical link should be
        /// disconnected before the ACL connection on the same physical connection
        /// is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.6) It is important to leave an 100 ms blank window before sending
        /// any new command (including system hardware reset), since immediately
        /// after <see cref="EventProcessor.DisconnectionCompleteEvent"/> event, system could save
        /// important information in non volatile memory.
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="reason">The reason for ending the connection.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Disconnect(ushort connectionHandle, Reason reason)
        {
            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)reason;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will obtain the values for the version information for
        /// the remote device identified by the <see cref="connectionHandle"/> parameter. The
        /// <see cref="connectionHandle"/> must be a <see cref="connectionHandle"/> for an ACL or LE
        /// connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.23)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's version
        /// information to get.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <seealso cref="EventProcessor.ReadRemoteVersionInformationCompleteEvent"/>
        public BleStatus ReadRemoteVersionInformation(ushort connectionHandle)
        {
            var command = BitConverter.GetBytes(connectionHandle);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which events are
        /// generated by the HCI for the Host.  If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// For an LE Controller, the LE Meta Event bit in the <see cref="eventMask"/> shall
        /// enable or disable all LE events in the LE Meta Event (see Section
        /// 7.7.65). The Host has to deal with each event that occurs. The event
        /// mask allows the Host to control how much it is interrupted. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)
        /// </summary>
        /// <param name="eventMask">Event mask. Default: 0x00001FFFFFFFFFFF</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus SetEventMask(HciEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will reset the Link Layer on an LE Controller.  The
        /// Reset command shall not affect the used HCI transport layer since the
        /// HCI transport layers may have reset mechanisms of their own. After the
        /// reset is completed, the current operational state will be lost, the
        /// Controller will enter standby mode and the Controller will
        /// automatically revert to the default values for the parameters for
        /// which default values are defined in the specification. Note: The Reset
        /// command will not necessarily perform a hardware reset. This is
        /// implementation defined.  The Host shall not send additional HCI
        /// commands before the Command Complete event related to the Reset
        /// command has been received. (See Bluetooth Specification v.4.1, Vol. 2,
        /// Part E, 7.3.2)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Reset()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x003,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the <see cref="transmitPowerLevel"/> parameter
        /// for the specified <see cref="connectionHandle"/>. The <see cref="connectionHandle"/> shall be a
        /// <see cref="connectionHandle"/> for an ACL connection. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.3.35)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's Transmit Power
        /// Level setting to read.</param>
        /// <param name="type">Current or maximum transmit power level.</param>
        /// <param name="transmitPowerLevel">Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadTransmitPowerLevel(ushort connectionHandle, TransmitPowerLevelType type, ref int transmitPowerLevel)
        {
            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)type;
            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x02d,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            transmitPowerLevel = response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the version information for the
        /// local Controller. The HCI Version information defines the version
        /// information of the HCI layer. The LMP/PAL Version information defines
        /// the version of the LMP or PAL. The <see cref="manufacturerName"/> information
        /// indicates the manufacturer of the local device. The HCI Revision and
        /// LMP/PAL Subversion are implementation dependent. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.4.1)
        /// </summary>
        /// <param name="version">See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="revision">Revision of the Current HCI in the BR/EDR Controller.</param>
        /// <param name="palVersion">Version of the Current LMP or PAL in the Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="manufacturerName">Manufacturer Name of the BR/EDR Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="palSubVersion">Subversion of the Current LMP or PAL in the Controller. This value is implementation dependent.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalVersionInformation(
            ref byte version,
            ref ushort revision,
            ref byte palVersion,
            ref ushort manufacturerName,
            ref ushort palSubVersion)
        {
            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x001,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            version = response[1];
            revision = BitConverter.ToUInt16(response, 2);
            palVersion = response[4];
            manufacturerName = BitConverter.ToUInt16(response, 5);
            palSubVersion = BitConverter.ToUInt16(response, 7);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the list of HCI commands supported for the local
        /// Controller. This command shall return the <see cref="supportedCommands"/> 
        /// configuration parameter. It is implied that if a command is listed as
        /// supported, the feature underlying that command is also supported. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)
        /// </summary>
        /// <param name="supportedCommands">Bit mask for each HCI Command. If a bit is 1,
        /// the Controller supports the corresponding command and the
        /// features required for the command.Unsupported or undefined
        /// commands shall be set to 0.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="supportedCommands"/> has to have a length of 64.</exception>
        public BleStatus ReadLocalSupportedCommands(ref byte[] supportedCommands)
        {
            if (supportedCommands is null || supportedCommands.Length != 64)
                throw new ArgumentException();
            var response = new byte[65];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 65
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            Array.Copy(response, 1, supportedCommands, 0, 64);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests a list of the supported features for the local
        /// Controller. This command will return a list of the LMP features. For
        /// details see Part C, Link Manager Protocol Specification on page 227.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LMP features.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalSupportedFeatures(ref ulong features)
        {
            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// On an LE Controller, this command shall read the Public Device Address
        /// as defined in [Vol 6] Part B, Section 1.3, Device Address. If this
        /// Controller does not have a Public Device Address, the value
        /// 0x000000000000 shall be returned. On an LE Controller, the public
        /// address shall be the same as the <see cref="address"/>. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.4.6)
        /// </summary>
        /// <param name="address">Bluetooth device address of the device.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="address"/> has to have a length of 6.</exception>
        public BleStatus ReadBluetoothDeviceAddress(ref byte[] address)
        {
            if (address is null || address.Length != 6)
                throw new ArgumentException();
            var response = new byte[7];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 7
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            Array.Copy(response, 1, address, 0, 6);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the Received Signal Strength Indication (RSSI)
        /// value from a Controller. For an LE transport, a <see cref="connectionHandle"/> is
        /// used as the Handle command parameter and return parameter. The meaning
        /// of the RSSI metric is an absolute receiver signal strength value in
        /// dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric
        /// shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part
        /// E, 7.5.4)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="rssi">N Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadRssi(ushort connectionHandle, ref sbyte rssi)
        {
            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            rssi = (sbyte)response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which LE events are
        /// generated by the HCI for the Host. If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// The Host has to deal with each event that is generated by an LE
        /// Controller. The event mask allows the Host to control which events
        /// will interrupt it. For LE events to be generated, the LE Meta-Event
        /// bit in the Event_Mask shall also be set. If that bit is not set, then
        /// LE events shall not be generated, regardless of how the <see cref="eventMask"/>
        /// is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)
        /// </summary>
        /// <param name="eventMask">LE event mask. Default: 0x000000000000001F.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetEventMask(LeEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to read the maximum size of
        /// the data portion of HCI LE ACL Data Packets sent from the Host to the
        /// Controller. The Host will segment the data transmitted to the
        /// Controller according to these values, so that the HCI Data Packets
        /// will contain data with up to this size. This
        /// command also returns the total number of HCI LE ACL Data Packets that
        /// can be stored in the data buffers of the Controller. This
        /// command must be issued by the Host before it sends
        /// any data to an LE Controller (see Section 4.1.1). If the Controller
        /// returns a length value of zero, the Host shall use the ReadBufferSize
        /// command to determine the size of the data buffers
        /// Note: Both the ReadBufferSize and <see cref="LeReadBufferSize"/> commands may
        /// return buffer length and number of packets parameter values that are
        /// nonzero. The <see cref="packetLength"/> return parameter shall be
        /// used to determine the size of the L2CAP PDU segments contained in ACL
        /// Data Packets, which are transferred from the Host to the Controller to
        /// be broken up into packets by the Link Layer. Both the Host and the
        /// Controller shall support command and event packets, where the data
        /// portion (excluding header) contained in the packets is 255 octets in
        /// size. The <see cref="packetCount"/> return parameter contains
        /// the total number of HCI ACL Data Packets that can be stored in the
        /// data buffers of the Controller. The Host determines how the buffers
        /// are to be divided between different Connection Handles. Note: The
        /// <see cref="packetLength"/> return parameter does not include the
        /// length of the HCI Data Packet header. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.8.2)
        /// </summary>
        /// <param name="packetLength">
        /// 0x0000 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x0001 - 0xFFFF Maximum length (in octets) of the data portion of each HCI ACL Data Packet that the Controller is able to accept.
        /// </param>
        /// <param name="packetCount">
        /// 0x00 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x01 - 0xFF Total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller.
        /// </param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadBufferSize(ref ushort packetLength, ref byte packetCount)
        {
            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 4
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            packetLength = BitConverter.ToUInt16(response, 1);
            packetCount = response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests the list of the supported LE features for the
        /// Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LE features. See Core v4.1, Vol. 6,
        /// Part B, Section 4.6.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadLocalSupportedFeatures(ref ulong features)
        {
            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used by the Host to set the LE
        /// Random Device Address in the Controller (see [Vol 6] Part B, Section
        /// 1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)
        /// </summary>
        /// <param name="randomAddress">Random device address.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="randomAddress"/> has to be an array of lenght 6.</exception>
        public BleStatus LeSetRandomAddress(byte[] randomAddress)
        {
            if (randomAddress is null || randomAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[6];
            Array.Copy(randomAddress, command, 6);
            var response = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x005,
                CommandParameter = command,
                CommandLength = 6,
                ResponseParameter = response,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return (BleStatus)response[0];
        }

        /// <summary>
        /// This command is used by the Host to set
        /// the advertising parameters. The <see cref="minAdvertisingInterval"/> shall be less
        /// than or equal to the <see cref="maxAdvertisingInterval"/>. The
        /// <see cref="minAdvertisingInterval"/> and <see cref="maxAdvertisingInterval"/> should not be
        /// the same value to enable the Controller to determine the best
        /// advertising interval given other activities. For high duty cycle
        /// directed advertising, i.e. when <see cref="advertisingType"/> is 0x01
        /// (ADV_DIRECT_IND, high duty cycle), the <see cref="minAdvertisingInterval"/> and
        /// <see cref="maxAdvertisingInterval"/> parameters are not used and shall be ignored.
        /// The <see cref="advertisingType"/> is used to determine the packet type that is used
        /// for advertising when advertising is enabled. <see cref="ownAddressType"/>
        /// parameter indicates the type of address being used in the advertising
        /// packets. If <see cref="ownAddressType"/> equals 0x02 or 0x03, the <see cref="peerAddress"/> 
        /// parameter contains the peer's Identity Address and the
        /// <see cref="peerAddressType"/> parameter contains the Peer's Identity Type (i.e.
        /// 0x00 or 0x01). These parameters are used to locate the corresponding
        /// local IRK in the resolving list; this IRK is used to generate the own
        /// address used in the advertisement. If directed advertising is
        /// performed, i.e. when <see cref="advertisingType"/> is set to 0x01 (ADV_DIRECT_IND,
        /// high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then
        /// the <see cref="peerAddressType"/> and <see cref="peerAddress"/> shall be valid. If
        /// <see cref="ownAddressType"/> equals 0x02 or 0x03, the Controller generates the
        /// peer's Resolvable Private Address using the peer's IRK corresponding
        /// to the peer's Identity Address contained in the <see cref="peerAddress"/> parameter
        /// and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the
        /// <see cref="peerAddressType"/> parameter. The <see cref="advertisingChannelMap"/> is a bit
        /// field that indicates the advertising channels that shall be used when
        /// transmitting advertising packets. At least one channel bit shall be
        /// set in the <see cref="advertisingChannelMap"/> parameter. The
        /// <see cref="advertisingFilterPolicy"/> parameter shall be ignored when directed
        /// advertising is enabled. The Host shall not issue this command when
        /// advertising is enabled in the Controller; if it is the Command
        /// Disallowed error code shall be used. If the advertising interval range
        /// provided by the Host (<see cref="minAdvertisingInterval"/>,
        /// <see cref="maxAdvertisingInterval"/>) is outside the advertising interval range
        /// supported by the Controller, then the Controller shall return the
        /// Unsupported Feature or Parameter Value (0x11) error code.
        /// </summary>
        /// <param name="minAdvertisingInterval">Minimum advertising interval for undirected
        /// and low duty cycle directed advertising. Time = N * 0.625 msec.</param>
        /// <param name="maxAdvertisingInterval">Maximum advertising interval. Time = N * 0.625 msec.</param>
        /// <param name="advertisingType">Advertising type.</param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.
        /// </item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local
        ///     IRK from resolving list. If resolving list contains no matching entry,
        ///     use random address from LE_Set_Random_Address.
        /// </item>
        /// </list>
        /// </param>
        /// <param name="peerAddressType">Peer Address type.</param>
        /// <param name="peerAddress"> Public Device Address, Random Device Address, Public
        /// Identity Address or Random (static) Identity Address of the device to
        /// be connected.</param>
        /// <param name="advertisingChannelMap">Advertising channel map. Default: 00000111b
        /// (all channels enabled).</param>
        /// <param name="advertisingFilterPolicy">Advertising filter policy.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="peerAddress"/> needs to be an array of length 6.</exception>
        public BleStatus LeSetAdvertisingParameters(
            ushort minAdvertisingInterval,
            ushort maxAdvertisingInterval,
            AdvertisingType advertisingType,
            AddressType ownAddressType,
            AddressType peerAddressType,
            byte[] peerAddress,
            ChannelMap advertisingChannelMap,
            FilterPolicy advertisingFilterPolicy)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[15];
            BitConverter.GetBytes(minAdvertisingInterval).CopyTo(command, 0);
            BitConverter.GetBytes(maxAdvertisingInterval).CopyTo(command, 2);
            command[4] = (byte)advertisingType;
            command[5] = (byte)ownAddressType;
            command[6] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 7);
            command[13] = (byte)advertisingChannelMap;
            command[14] = (byte)advertisingFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x006,
                CommandParameter = command,
                CommandLength = 15,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeReadAdvertisingChannelTxPower(ref sbyte transmitPowerLevel)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetAdvertisingData(byte advertisingDataLength, byte[] advertisingData)
        {
            if (advertisingData is null || advertisingData.Length != 31)
                throw new ArgumentException($"{nameof(advertisingData)} has to be an array of length 31");
            var command = new byte[32];
            command[0] = advertisingDataLength;
            advertisingData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x008,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeSetScanResponseData(byte scanResponseDataLength, byte[] scanResponseData)
        {
            if (scanResponseDataLength > 31)
                throw new ArgumentException($"{nameof(scanResponseData)} has to be an array of length 31 or less");
            var command = new byte[32];
            command[0] = scanResponseDataLength;
            if (scanResponseData is not null)
                scanResponseData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x009,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeSetAdvertiseEnable(bool enableAdvertising)
        {
            var command = new byte[1];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00a,
                CommandParameter = command,
                CommandLength = 1,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeSetScanParameters(
            ScanType scanType,
            ushort scanInterval,
            ushort scanWindow,
            AddressType ownAddressType,
            FilterPolicy scanningFilterPolicy)
        {
            var command = new byte[7];
            command[0] = (byte)scanType;
            BitConverter.GetBytes(scanInterval).CopyTo(command, 1);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 3);
            command[5] = (byte)ownAddressType;
            command[6] = (byte)scanningFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00b,
                CommandParameter = command,
                CommandLength = 7,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeSetScanEnable(bool enableAdvertising, bool filterDuplicates)
        {
            var command = new byte[2];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            command[1] = (byte)(filterDuplicates ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00c,
                CommandParameter = command,
                CommandLength = 2,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeCreateConnection(
            ushort scanInterval,
            ushort scanWindow,
            bool useWhiteList,
            AddressType peerAddressType,
            byte[] peerAddress,
            AddressType ownAddressType,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionLength,
            ushort maximumConnectionLength)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException($"{nameof(peerAddress)} needs to be an array of length 6");
            var command = new byte[24];
            BitConverter.GetBytes(scanInterval).CopyTo(command, 0);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 2);
            command[4] = (byte)(useWhiteList ? 0x01 : 0x00);
            command[5] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 6);
            command[12] = (byte)ownAddressType;
            BitConverter.GetBytes(minimumConnectionInterval).CopyTo(command, 13);
            BitConverter.GetBytes(maximumConnectionInterval).CopyTo(command, 15);
            BitConverter.GetBytes(connectionLatency).CopyTo(command, 17);
            BitConverter.GetBytes(supervisionTimeout).CopyTo(command, 19);
            BitConverter.GetBytes(minimumConnectionLength).CopyTo(command, 21);
            BitConverter.GetBytes(maximumConnectionLength).CopyTo(command, 23);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00d,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 24,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeCreateConnectionCancel()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00e,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeReadWhitelistSize(ref byte whiteListSize)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeClearWhiteList()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x010,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        public BleStatus LeAddDeviceToWhitelist(AddressType addressType, byte[] address)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRemoveDeviceFromWhitelist(AddressType addressType, byte[] address)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeConnectionUpdate(
            ushort connectionHandle,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionLength,
            ushort maximumConnectionLength)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetHostChannelClassification(byte[] channelMap)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadChannelMap(ushort connectionHandle, byte[] channelMap)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadRemoteUsedFeatures(ushort connectionHandle)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeEncrypt(byte[] key, byte[] plaintextData, ref byte[] encryptedData)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRandom(ref byte[] randomNumber)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeStartEncryption(ushort connectionHandle, byte[] randomNumber, ushort encryptedDiversifier, byte[] longTermKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeLongTermKeyRequestReply(ushort connectionHandle, byte[] longTermKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeLongTermKeyRequestedNegativeReply(ushort connectionHandle)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadSupportedStates(ref byte[] states)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReceiverTest(byte rxFrequency)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeTransmitterTest(byte txFrequency, byte testDataLength, byte packetPayload)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeTestEnd(ref ushort numberOfPackets)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetDataLength(ushort connectionHandle, ushort transmissionOctets, ushort transmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadSuggestedDefaultDataLength(ref ushort suggestedMaximumTransmissionOctets, ref ushort suggestedMaxTransmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeWriteSuggestedDefaultDataLength(ushort suggestedMaximumTransmissionOctets, ushort suggestedMaxTransmissionTime)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadLocalP256PublicKey()
        {
            throw new NotImplementedException();
        }

        public BleStatus LeGenerateDhKey(byte[] remoteP256PublicKey)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeAddDeviceToResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, byte[] peerIrk, byte[] localIrk)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeRemoveDeviceFromResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeClearResolvingList()
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadResolvingListSize(ref byte resolvingListSize)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadPeerResolvableAddress(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, ref byte[] peerResolvableAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadLocalResolvableAddress(
            AddressType peerIdentityAddressType,
            byte[] peerIdentityAddress,
            ref byte[] localResolvableAddress)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetAddressResolutionEnable(bool enableAddressResolution)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeSetResolvablePrivateAddressTimeout(ushort rpaTimeout)
        {
            throw new NotImplementedException();
        }

        public BleStatus LeReadMaximumDataLength(
            ref ushort supportedMaximumOctets,
            ref ushort supportedMaximumTransmissionTime,
            ref ushort supportedMaximumReceivingOctets,
            ref ushort supportedMaxReceivingTime)
        {
            throw new NotImplementedException();
        }

        internal void UserEventProcess()
        {
            _transportLayer.UserEventProcess();
        }
    }

    /// <summary>
    /// Event mask for bluetooth LE events.
    /// </summary>
    public enum LeEventMask : ulong
    {
        /// <summary>
        /// No LE events specified.
        /// </summary>
        None = 0x0000000000000000,

        /// <summary>
        /// Connection complete event bit.
        /// </summary>
        ConnectionCompleteEvent = 0x0000000000000001,

        /// <summary>
        /// Advertising report event bit.
        /// </summary>
        AdvertisingReportEvent = 0x0000000000000002,

        /// <summary>
        /// Connection update complete event bit.
        /// </summary>
        ConnectionUpdateCompleteEvent = 0x0000000000000004,

        /// <summary>
        /// Read remote used features complete event bit.
        /// </summary>
        ReadRemoteUsedFeaturesCompleteEvent = 0x0000000000000008,

        /// <summary>
        /// Long term key request event bit.
        /// </summary>
        LongTermKeyRequestEvent = 0x0000000000000010,

        /// <summary>
        /// Remote connection parameter request event bit.
        /// </summary>
        RemoteConnectionParameterRequestEvent = 0x0000000000000020,

        /// <summary>
        /// Data length change event bit.
        /// </summary>
        DataLengthChangeEvent = 0x0000000000000040,

        /// <summary>
        /// Read local P-256 public key complete event bit.
        /// </summary>
        ReadPublicKeyCompleteEvent = 0x0000000000000080,

        /// <summary>
        /// Generate DHKey complete event bit.
        /// </summary>
        GenerateDhKeyCompleteEvent = 0x0000000000000100,

        /// <summary>
        /// Enhanced connection complete event bit.
        /// </summary>
        EnhancedConnectionCompleteEvent = 0x0000000000000200,

        /// <summary>
        /// Direct advertising report event bit.
        /// </summary>
        DirectAdvertisingReportEvent = 0x0000000000000400,
    }
}
