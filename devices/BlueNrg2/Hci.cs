// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using Iot.Device.BlueNrg2.Aci;
using Iot.Device.BlueNrg2.Aci.Events;

namespace Iot.Device.BlueNrg2
{
    /// <summary>
    /// Class containing all the HCI commands.
    /// </summary>
    public class Hci
    {
        private readonly TransportLayer _transportLayer;

        internal Hci(TransportLayer transportLayer)
        {
            _transportLayer = transportLayer;
        }

        internal void Init()
        {
            _transportLayer.Reset();
        }

        /// <summary>
        /// This is used to terminate an existing connection.
        /// The <see cref="connectionHandle"/> command parameter indicates which connection is
        /// to be disconnected. The <see cref="reason"/> command parameter indicates the reason
        /// for ending the connection. The remote Controller will receive the
        /// <see cref="reason"/> command parameter in the <see cref="EventProcessor.DisconnectionCompleteEvent"/>
        /// event. All synchronous connections on a physical link should be
        /// disconnected before the ACL connection on the same physical connection
        /// is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.6) It is important to leave an 100 ms blank window before sending
        /// any new command (including system hardware reset), since immediately
        /// after <see cref="EventProcessor.DisconnectionCompleteEvent"/> event, system could save
        /// important information in non volatile memory.
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="reason">The reason for ending the connection.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Disconnect(ushort connectionHandle, Reason reason)
        {
            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)reason;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will obtain the values for the version information for
        /// the remote device identified by the <see cref="connectionHandle"/> parameter. The
        /// <see cref="connectionHandle"/> must be a <see cref="connectionHandle"/> for an ACL or LE
        /// connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.1.23)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's version
        /// information to get.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <seealso cref="EventProcessor.ReadRemoteVersionInformationCompleteEvent"/>
        public BleStatus ReadRemoteVersionInformation(ushort connectionHandle)
        {
            var command = BitConverter.GetBytes(connectionHandle);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x01,
                OpCodeCommand = 0x006,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which events are
        /// generated by the HCI for the Host.  If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// For an LE Controller, the LE Meta Event bit in the <see cref="eventMask"/> shall
        /// enable or disable all LE events in the LE Meta Event (see Section
        /// 7.7.65). The Host has to deal with each event that occurs. The event
        /// mask allows the Host to control how much it is interrupted. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)
        /// </summary>
        /// <param name="eventMask">Event mask. Default: 0x00001FFFFFFFFFFF</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus SetEventMask(HciEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command will reset the Link Layer on an LE Controller.  The
        /// Reset command shall not affect the used HCI transport layer since the
        /// HCI transport layers may have reset mechanisms of their own. After the
        /// reset is completed, the current operational state will be lost, the
        /// Controller will enter standby mode and the Controller will
        /// automatically revert to the default values for the parameters for
        /// which default values are defined in the specification. Note: The Reset
        /// command will not necessarily perform a hardware reset. This is
        /// implementation defined.  The Host shall not send additional HCI
        /// commands before the Command Complete event related to the Reset
        /// command has been received. (See Bluetooth Specification v.4.1, Vol. 2,
        /// Part E, 7.3.2)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus Reset()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x003,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the <see cref="transmitPowerLevel"/> parameter
        /// for the specified <see cref="connectionHandle"/>. The <see cref="connectionHandle"/> shall be a
        /// <see cref="connectionHandle"/> for an ACL connection. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.3.35)
        /// </summary>
        /// <param name="connectionHandle">Specifies which Connection_Handle's Transmit Power
        /// Level setting to read.</param>
        /// <param name="type">Current or maximum transmit power level.</param>
        /// <param name="transmitPowerLevel">Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadTransmitPowerLevel(ushort connectionHandle, TransmitPowerLevelType type, out sbyte transmitPowerLevel)
        {
            transmitPowerLevel = 0;

            var command = new byte[3];
            BitConverter.GetBytes(connectionHandle).CopyTo(command, 0);
            command[2] = (byte)type;
            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x03,
                OpCodeCommand = 0x02d,
                CommandParameter = command,
                CommandLength = 3,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            transmitPowerLevel = (sbyte)response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the values for the version information for the
        /// local Controller. The HCI Version information defines the version
        /// information of the HCI layer. The LMP/PAL Version information defines
        /// the version of the LMP or PAL. The <see cref="manufacturerName"/> information
        /// indicates the manufacturer of the local device. The HCI Revision and
        /// LMP/PAL Subversion are implementation dependent. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.4.1)
        /// </summary>
        /// <param name="version">See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="revision">Revision of the Current HCI in the BR/EDR Controller.</param>
        /// <param name="palVersion">Version of the Current LMP or PAL in the Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="manufacturerName">Manufacturer Name of the BR/EDR Controller. See Bluetooth Assigned Numbers (https://www.bluetooth.org/en-us/specification/assigned-numbers)</param>
        /// <param name="palSubVersion">Subversion of the Current LMP or PAL in the Controller. This value is implementation dependent.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalVersionInformation(
            out byte version,
            out ushort revision,
            out byte palVersion,
            out ushort manufacturerName,
            out ushort palSubVersion)
        {
            version = 0;
            revision = 0;
            palVersion = 0;
            manufacturerName = 0;
            palSubVersion = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x001,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            version = response[1];
            revision = BitConverter.ToUInt16(response, 2);
            palVersion = response[4];
            manufacturerName = BitConverter.ToUInt16(response, 5);
            palSubVersion = BitConverter.ToUInt16(response, 7);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the list of HCI commands supported for the local
        /// Controller. This command shall return the <see cref="supportedCommands"/> 
        /// configuration parameter. It is implied that if a command is listed as
        /// supported, the feature underlying that command is also supported. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)
        /// </summary>
        /// <param name="supportedCommands">Bit mask for each HCI Command. If a bit is 1,
        /// the Controller supports the corresponding command and the
        /// features required for the command.Unsupported or undefined
        /// commands shall be set to 0.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="supportedCommands"/> has to have a length of 64.</exception>
        public BleStatus ReadLocalSupportedCommands(out byte[] supportedCommands)
        {
            supportedCommands = null;

            var response = new byte[65];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 65
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            supportedCommands = new byte[64];

            Array.Copy(response, 1, supportedCommands, 0, 64);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests a list of the supported features for the local
        /// Controller. This command will return a list of the LMP features. For
        /// details see Part C, Link Manager Protocol Specification on page 227.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LMP features.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadLocalSupportedFeatures(out ulong features)
        {
            features = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// On an LE Controller, this command shall read the Public Device Address
        /// as defined in [Vol 6] Part B, Section 1.3, Device Address. If this
        /// Controller does not have a Public Device Address, the value
        /// 0x000000000000 shall be returned. On an LE Controller, the public
        /// address shall be the same as the <see cref="address"/>. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.4.6)
        /// </summary>
        /// <param name="address">Bluetooth device address of the device.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="address"/> has to have a length of 6.</exception>
        public BleStatus ReadBluetoothDeviceAddress(out byte[] address)
        {
            address = null;

            var response = new byte[7];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 7
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            address = new byte[6];
            Array.Copy(response, 1, address, 0, 6);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command reads the Received Signal Strength Indication (RSSI)
        /// value from a Controller. For an LE transport, a <see cref="connectionHandle"/> is
        /// used as the Handle command parameter and return parameter. The meaning
        /// of the RSSI metric is an absolute receiver signal strength value in
        /// dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric
        /// shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part
        /// E, 7.5.4)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="rssi">N Size: 1 Octet (signed integer) Units: dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus ReadRssi(ushort connectionHandle, out sbyte rssi)
        {
            rssi = 0;

            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x04,
                OpCodeCommand = 0x009,
                ResponseParameter = response,
                ResponseLength = 4
            };

            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            rssi = (sbyte)response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to control which LE events are
        /// generated by the HCI for the Host. If the bit in the <see cref="eventMask"/> is
        /// set to a one, then the event associated with that bit will be enabled.
        /// The Host has to deal with each event that is generated by an LE
        /// Controller. The event mask allows the Host to control which events
        /// will interrupt it. For LE events to be generated, the LE Meta-Event
        /// bit in the Event_Mask shall also be set. If that bit is not set, then
        /// LE events shall not be generated, regardless of how the <see cref="eventMask"/>
        /// is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)
        /// </summary>
        /// <param name="eventMask">LE event mask. Default: 0x000000000000001F.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetEventMask(LeEventMask eventMask)
        {
            var command = BitConverter.GetBytes((ulong)eventMask);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x001,
                CommandParameter = command,
                CommandLength = 8,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to read the maximum size of
        /// the data portion of HCI LE ACL Data Packets sent from the Host to the
        /// Controller. The Host will segment the data transmitted to the
        /// Controller according to these values, so that the HCI Data Packets
        /// will contain data with up to this size. This
        /// command also returns the total number of HCI LE ACL Data Packets that
        /// can be stored in the data buffers of the Controller. This
        /// command must be issued by the Host before it sends
        /// any data to an LE Controller (see Section 4.1.1). If the Controller
        /// returns a length value of zero, the Host shall use the ReadBufferSize
        /// command to determine the size of the data buffers
        /// Note: Both the ReadBufferSize and <see cref="LeReadBufferSize"/> commands may
        /// return buffer length and number of packets parameter values that are
        /// nonzero. The <see cref="packetLength"/> return parameter shall be
        /// used to determine the size of the L2CAP PDU segments contained in ACL
        /// Data Packets, which are transferred from the Host to the Controller to
        /// be broken up into packets by the Link Layer. Both the Host and the
        /// Controller shall support command and event packets, where the data
        /// portion (excluding header) contained in the packets is 255 octets in
        /// size. The <see cref="packetCount"/> return parameter contains
        /// the total number of HCI ACL Data Packets that can be stored in the
        /// data buffers of the Controller. The Host determines how the buffers
        /// are to be divided between different Connection Handles. Note: The
        /// <see cref="packetLength"/> return parameter does not include the
        /// length of the HCI Data Packet header. (See Bluetooth Specification
        /// v.4.1, Vol. 2, Part E, 7.8.2)
        /// </summary>
        /// <param name="packetLength">
        /// 0x0000 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x0001 - 0xFFFF Maximum length (in octets) of the data portion of each HCI ACL Data Packet that the Controller is able to accept.
        /// </param>
        /// <param name="packetCount">
        /// 0x00 No dedicated LE Buffer - use Read_Buffer_Size command.
        /// 0x01 - 0xFF Total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller.
        /// </param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadBufferSize(out ushort packetLength, out byte packetCount)
        {
            packetLength = 0;
            packetCount = 0;

            var response = new byte[4];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x002,
                ResponseParameter = response,
                ResponseLength = 4
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            packetLength = BitConverter.ToUInt16(response, 1);
            packetCount = response[3];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests the list of the supported LE features for the
        /// Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)
        /// </summary>
        /// <param name="features">Bit Mask List of LE features. See Core v4.1, Vol. 6,
        /// Part B, Section 4.6.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadLocalSupportedFeatures(out ulong features)
        {
            features = 0;

            var response = new byte[9];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x003,
                ResponseParameter = response,
                ResponseLength = 9
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            features = BitConverter.ToUInt64(response, 1);
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used by the Host to set the LE
        /// Random Device Address in the Controller (see [Vol 6] Part B, Section
        /// 1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)
        /// </summary>
        /// <param name="randomAddress">Random device address.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="randomAddress"/> has to be an array of lenght 6.</exception>
        public BleStatus LeSetRandomAddress(byte[] randomAddress)
        {
            if (randomAddress is null || randomAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[6];
            Array.Copy(randomAddress, command, 6);
            var response = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x005,
                CommandParameter = command,
                CommandLength = 6,
                ResponseParameter = response,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return (BleStatus)response[0];
        }

        /// <summary>
        /// This command is used by the Host to set
        /// the advertising parameters. The <see cref="minAdvertisingInterval"/> shall be less
        /// than or equal to the <see cref="maxAdvertisingInterval"/>. The
        /// <see cref="minAdvertisingInterval"/> and <see cref="maxAdvertisingInterval"/> should not be
        /// the same value to enable the Controller to determine the best
        /// advertising interval given other activities. For high duty cycle
        /// directed advertising, i.e. when <see cref="advertisingType"/> is 0x01
        /// (ADV_DIRECT_IND, high duty cycle), the <see cref="minAdvertisingInterval"/> and
        /// <see cref="maxAdvertisingInterval"/> parameters are not used and shall be ignored.
        /// The <see cref="advertisingType"/> is used to determine the packet type that is used
        /// for advertising when advertising is enabled. <see cref="ownAddressType"/>
        /// parameter indicates the type of address being used in the advertising
        /// packets. If <see cref="ownAddressType"/> equals 0x02 or 0x03, the <see cref="peerAddress"/> 
        /// parameter contains the peer's Identity Address and the
        /// <see cref="peerAddressType"/> parameter contains the Peer's Identity Type (i.e.
        /// 0x00 or 0x01). These parameters are used to locate the corresponding
        /// local IRK in the resolving list; this IRK is used to generate the own
        /// address used in the advertisement. If directed advertising is
        /// performed, i.e. when <see cref="advertisingType"/> is set to 0x01 (ADV_DIRECT_IND,
        /// high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then
        /// the <see cref="peerAddressType"/> and <see cref="peerAddress"/> shall be valid. If
        /// <see cref="ownAddressType"/> equals 0x02 or 0x03, the Controller generates the
        /// peer's Resolvable Private Address using the peer's IRK corresponding
        /// to the peer's Identity Address contained in the <see cref="peerAddress"/> parameter
        /// and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the
        /// <see cref="peerAddressType"/> parameter. The <see cref="advertisingChannelMap"/> is a bit
        /// field that indicates the advertising channels that shall be used when
        /// transmitting advertising packets. At least one channel bit shall be
        /// set in the <see cref="advertisingChannelMap"/> parameter. The
        /// <see cref="advertisingFilterPolicy"/> parameter shall be ignored when directed
        /// advertising is enabled. The Host shall not issue this command when
        /// advertising is enabled in the Controller; if it is the Command
        /// Disallowed error code shall be used. If the advertising interval range
        /// provided by the Host (<see cref="minAdvertisingInterval"/>,
        /// <see cref="maxAdvertisingInterval"/>) is outside the advertising interval range
        /// supported by the Controller, then the Controller shall return the
        /// Unsupported Feature or Parameter Value (0x11) error code.
        /// </summary>
        /// <param name="minAdvertisingInterval">Minimum advertising interval for undirected
        /// and low duty cycle directed advertising. Time = N * 0.625 ms.</param>
        /// <param name="maxAdvertisingInterval">Maximum advertising interval. Time = N * 0.625 ms.</param>
        /// <param name="advertisingType">Advertising type.</param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.
        /// </item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local
        ///     IRK from resolving list. If resolving list contains no matching entry,
        ///     use random address from LE_Set_Random_Address.
        /// </item>
        /// </list>
        /// </param>
        /// <param name="peerAddressType">Peer Address type.</param>
        /// <param name="peerAddress"> Public Device Address, Random Device Address, Public
        /// Identity Address or Random (static) Identity Address of the device to
        /// be connected.</param>
        /// <param name="advertisingChannelMap">Advertising channel map. Default: 00000111b
        /// (all channels enabled).</param>
        /// <param name="advertisingFilterPolicy">Advertising filter policy.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="peerAddress"/> needs to be an array of length 6.</exception>
        public BleStatus LeSetAdvertisingParameters(
            ushort minAdvertisingInterval,
            ushort maxAdvertisingInterval,
            AdvertisingType advertisingType,
            AddressType ownAddressType,
            AddressType peerAddressType,
            byte[] peerAddress,
            ChannelMap advertisingChannelMap,
            FilterPolicy advertisingFilterPolicy)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[15];
            BitConverter.GetBytes(minAdvertisingInterval).CopyTo(command, 0);
            BitConverter.GetBytes(maxAdvertisingInterval).CopyTo(command, 2);
            command[4] = (byte)advertisingType;
            command[5] = (byte)ownAddressType;
            command[6] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 7);
            command[13] = (byte)advertisingChannelMap;
            command[14] = (byte)advertisingFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x006,
                CommandParameter = command,
                CommandLength = 15,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used by the Host
        /// to read the transmit power level used for LE advertising channel
        /// packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.6)
        /// </summary>
        /// <param name="transmitPowerLevel">Size: 1 Octet (signed integer) Units: dBm
        /// Accuracy: +/- 4 dBm</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadAdvertisingChannelTxPower(out sbyte transmitPowerLevel)
        {
            transmitPowerLevel = 0;

            const uint responseLength = 2;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x007,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            transmitPowerLevel = (sbyte)response[1];

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to set the data used in advertising packets that have a data
        /// field. Only the significant part of the <see cref="advertisingData"/> is
        /// transmitted in the advertising packets, as defined in [Vol 3] Part C,
        /// Section 11. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.7)
        /// </summary>
        /// <param name="advertisingDataLength">The number of significant octets in the following data field.</param>
        /// <param name="advertisingData">31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="advertisingData"/> has to be an array of length 31.</exception>
        public BleStatus LeSetAdvertisingData(byte advertisingDataLength, byte[] advertisingData)
        {
            if (advertisingData is null || advertisingData.Length != 31)
                throw new ArgumentException();
            var command = new byte[32];
            command[0] = advertisingDataLength;
            advertisingData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x008,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to provide data used in Scanning Packets that
        /// have a data field. Only the significant part of the <see cref="scanResponseData"/>
        /// is transmitted in the Scanning Packets, as defined in [Vol 3] Part C,
        /// Section 11. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.8)
        /// </summary>
        /// <param name="scanResponseDataLength">The number of significant octets in the
        /// following data field.</param>
        /// <param name="scanResponseData">31 octets of data formatted as defined in [Vol 3]
        /// Part C, Section 11.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="scanResponseData"/> has to be an array of length 31 or less</exception>
        public BleStatus LeSetScanResponseData(byte scanResponseDataLength, byte[] scanResponseData)
        {
            if (scanResponseDataLength > 31)
                throw new ArgumentException();
            var command = new byte[32];
            command[0] = scanResponseDataLength;
            if (scanResponseData is not null)
                scanResponseData.CopyTo(command, 1);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x009,
                CommandParameter = command,
                CommandLength = 32,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to request the Controller
        /// to start or stop advertising. The Controller manages the timing of
        /// advertisements as per the advertising parameters given in the
        /// <see cref="LeSetAdvertisingParameters"/> command. The Controller shall continue
        /// advertising until the Host issues an <see cref="LeSetAdvertiseEnable"/> command
        /// with <see cref="enableAdvertising"/> set to false (Advertising is disabled) or until
        /// a connection is created or until the Advertising is timed out due to
        /// high duty cycle Directed Advertising. In these cases, advertising is
        /// then disabled. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.9)
        /// </summary>
        /// <param name="enableAdvertising">Enable/disable advertise. Default is false (disabled).</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetAdvertiseEnable(bool enableAdvertising)
        {
            var command = new byte[1];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00a,
                CommandParameter = command,
                CommandLength = 1,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to set the scan parameters.
        /// The <see cref="ScanType"/> parameter controls the type of scan to perform. The
        /// <see cref="scanInterval"/> and <see cref="scanWindow"/> parameters are recommendations
        /// from the Host on how long (<see cref="scanWindow"/>) and how frequently
        /// (<see cref="scanInterval"/>) the Controller should scan (See [Vol 6] Part B,
        /// Section 4.5.3). The <see cref="scanWindow"/> parameter shall always be set to a
        /// value smaller or equal to the value set for the <see cref="scanInterval"/>
        /// parameter. If they are set to the same value scanning should be run
        /// continuously. The <see cref="ownAddressType"/> parameter determines the address
        /// used (Public or Random Device Address) when performing active scan.
        /// The Host shall not issue this command when scanning is enabled in the
        /// Controller; if it is the Command Disallowed error code shall be used.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.10)
        /// </summary>
        /// <param name="scanType">Passive or active scanning. With active scanning SCAN_REQ packets are sent.</param>
        /// <param name="scanInterval">
        /// This is defined as the time interval from when the Controller started
        /// its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 ms.
        /// </param>
        /// <param name="scanWindow">
        /// The duration of the LE scan. LE_Scan_Window shall be
        /// less than or equal to LE_Scan_Interval. Time = N * 0.625 ms.
        /// </param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.</item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use random address from LE_Set_Random_Address.</item>
        /// </list>
        /// </param>
        /// <param name="scanningFilterPolicy">
        /// <list type="bullet">
        /// <item>
        ///     0x00 Accept all advertisement packets. Directed advertising packets which
        ///     are not addressed for this device shall be ignored.
        /// </item>
        /// <item>
        ///     0x01 Ignore advertisement packets from devices not in the White List Only.
        ///     Directed advertising packets which are not addressed for this device shall be ignored.
        /// </item>
        /// <item>
        ///     0x02 Accept all undirected advertisement packets. Directed advertisement packets where
        ///     initiator address is a RPA and  Directed advertisement packets addressed to this device shall be accepted.
        /// </item>
        /// <item>
        ///     0x03 Accept all undirected advertisement packets from devices that are in the White List.
        ///     Directed advertisement packets where initiator address is RPA and Directed advertisement
        ///     packets addressed to this device shall be accepted.
        /// </item>
        /// </list>
        /// </param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetScanParameters(
            ScanType scanType,
            ushort scanInterval,
            ushort scanWindow,
            AddressType ownAddressType,
            FilterPolicy scanningFilterPolicy)
        {
            var command = new byte[7];
            command[0] = (byte)scanType;
            BitConverter.GetBytes(scanInterval).CopyTo(command, 1);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 3);
            command[5] = (byte)ownAddressType;
            command[6] = (byte)scanningFilterPolicy;
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00b,
                CommandParameter = command,
                CommandLength = 7,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to start scanning. Scanning is
        /// used to discover advertising devices nearby. The <see cref="filterDuplicates"/>
        /// parameter controls whether the Link Layer shall filter duplicate
        /// advertising reports to the Host, or if the Link Layer should generate
        /// advertising reports for each packet received. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.8.11)
        /// </summary>
        /// <param name="enableAdvertising">Enable/disable scan. Default is 0 (disabled).</param>
        /// <param name="filterDuplicates">Enable/disable duplicate filtering.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetScanEnable(bool enableAdvertising, bool filterDuplicates)
        {
            var command = new byte[2];
            command[0] = (byte)(enableAdvertising ? 0x01 : 0x00);
            command[1] = (byte)(filterDuplicates ? 0x01 : 0x00);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00c,
                CommandParameter = command,
                CommandLength = 2,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to create a Link Layer
        /// connection to a connectable advertiser. The <see cref="scanWindow"/> and
        /// <see cref="scanWindow"/> parameters are recommendations from the Host on how
        /// long (<see cref="scanWindow"/>) and how frequently (<see cref="scanInterval"/>) the
        /// Controller should scan. The <see cref="scanWindow"/> parameter shall be set to a
        /// value smaller or equal to the value set for the <see cref="scanInterval"/>
        /// parameter. If both are set to the same value, scanning should run
        /// continuously. The <see cref="useWhiteList"/> is used to determine whether
        /// the White List is used. If the White List is not used, the
        /// <see cref="peerAddressType"/> and the <see cref="peerAddress"/> parameters specify the address
        /// type and address of the advertising device to connect to. The Link
        /// Layer shall set the address in the CONNECT_REQ packets to either the
        /// Public Device Address or the Random Device Addressed based on the
        /// <see cref="ownAddressType"/> parameter. The <see cref="minimumConnectionInterval"/> and
        /// <see cref="maximumConnectionInterval"/> parameters define the minimum and maximum allowed
        /// connection interval. The <see cref="minimumConnectionInterval"/> parameter shall not be
        /// greater than the <see cref="maximumConnectionInterval"/> parameter. The <see cref="connectionLatency"/>
        /// parameter defines the maximum allowed connection latency (see [Vol 6]
        /// Part B, Section 4.5.1). The <see cref="supervisionTimeout"/> parameter defines the
        /// link supervision timeout for the connection. The <see cref="supervisionTimeout"/>
        /// in milliseconds shall be larger than (1 + <see cref="connectionLatency"/>) *
        /// <see cref="maximumConnectionInterval"/> * 2, where <see cref="maximumConnectionInterval"/> is given in
        /// milliseconds. (See [Vol 6] Part B, Section 4.5.2). The
        /// <see cref="minimumConnectionEventLength"/> and <see cref="maximumConnectionEventLength"/> parameters are informative
        /// parameters providing the Controller with the expected minimum and
        /// maximum length of the connection events. The <see cref="minimumConnectionEventLength"/>
        /// parameter shall be less than or equal to the <see cref="maximumConnectionEventLength"/>
        /// parameter. The Host shall not issue this command when another
        /// <see cref="LeCreateConnection"/> is pending in the Controller; if this does occur
        /// the Controller shall return the Command Disallowed error code shall be
        /// used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.12)
        /// </summary>
        /// <param name="scanInterval">
        /// This is defined as the time interval from when the
        /// Controller started its last LE scan until it begins the subsequent LE
        /// scan. Time = N * 0.625 ms.
        /// </param>
        /// <param name="scanWindow">
        /// The duration of the LE scan. <see cref="scanWindow"/> shall be
        /// less than or equal to <see cref="scanInterval"/>. Time = N * 0.625 ms.</param>
        /// <param name="useWhiteList">
        /// <list type="bullet">
        /// <item>false: White list is not used to determine which advertiser to connect to. Peer_Address_Type and Peer_Address shall be used.</item>
        /// <item>true: White list is used to determine which advertiser to connect to. Peer_Address_Type and Peer_Address shall be ignored.</item>
        /// </list>
        /// </param>
        /// <param name="peerAddressType">
        /// <list type="bullet">
        /// <item>0x00 Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>0x02 Public Identity Address (Corresponds to Resolved Private Address)</item>
        /// <item>0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</item>
        /// </list>
        /// </param>
        /// <param name="peerAddress">Public Device Address, Random Device Address, Public
        /// Identity Address or Random (static) Identity Address of the
        /// advertising device.</param>
        /// <param name="ownAddressType">Own address type.
        /// <list type="bullet">
        /// <item>0x00: Public Device Address</item>
        /// <item>0x01 Random Device Address</item>
        /// <item>
        ///     0x02: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use public address.
        /// </item>
        /// <item>
        ///     0x03: Controller generates Resolvable Private Address based on the local IRK from resolving list.
        ///     If resolving list contains no matching entry, use random address from <see cref="LeSetRandomAddress"/>.
        /// </item>
        /// </list>
        /// </param>
        /// <param name="minimumConnectionInterval">Minimum value for the connection event interval.
        /// This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 ms.</param>
        /// <param name="maximumConnectionInterval">Maximum value for the connection event interval.
        /// This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 ms.</param>
        /// <param name="connectionLatency">Slave latency for the connection in number of connection events.</param>
        /// <param name="supervisionTimeout">Supervision timeout for the LE Link. It shall be a
        /// multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 ms.</param>
        /// <param name="minimumConnectionEventLength">Information parameter about the minimum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <param name="maximumConnectionEventLength">Information parameter about the maximum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"><see cref="peerAddress"/> needs to be an array of length 6.</exception>
        public BleStatus LeCreateConnection(
            ushort scanInterval,
            ushort scanWindow,
            bool useWhiteList,
            AddressType peerAddressType,
            byte[] peerAddress,
            AddressType ownAddressType,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionEventLength,
            ushort maximumConnectionEventLength)
        {
            if (peerAddress is null || peerAddress.Length != 6)
                throw new ArgumentException();
            var command = new byte[24];
            BitConverter.GetBytes(scanInterval).CopyTo(command, 0);
            BitConverter.GetBytes(scanWindow).CopyTo(command, 2);
            command[4] = (byte)(useWhiteList ? 0x01 : 0x00);
            command[5] = (byte)peerAddressType;
            peerAddress.CopyTo(command, 6);
            command[12] = (byte)ownAddressType;
            BitConverter.GetBytes(minimumConnectionInterval).CopyTo(command, 13);
            BitConverter.GetBytes(maximumConnectionInterval).CopyTo(command, 15);
            BitConverter.GetBytes(connectionLatency).CopyTo(command, 17);
            BitConverter.GetBytes(supervisionTimeout).CopyTo(command, 19);
            BitConverter.GetBytes(minimumConnectionEventLength).CopyTo(command, 21);
            BitConverter.GetBytes(maximumConnectionEventLength).CopyTo(command, 23);
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00d,
                Event = 0x0F,
                CommandParameter = command,
                CommandLength = 24,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to cancel the <see cref="LeCreateConnection"/> command.
        /// This command shall only be issued after the <see cref="LeCreateConnection"/>
        /// command has been issued, a Command Status event has been received for the LE
        /// Create Connection command and before the LE Connection Complete event.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.13)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeCreateConnectionCancel()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00e,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to read the total number
        /// of white list entries that can be stored in the Controller. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.14)
        /// </summary>
        /// <param name="whiteListSize">Total number of white list entries that can be
        /// stored in the Controller.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadWhitelistSize(out byte whiteListSize)
        {
            whiteListSize = 0;

            const uint responseLength = 2;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x00f,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            whiteListSize = response[1];

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to clear the white list stored
        /// in the Controller. This command can be used at any time except when: -
        /// the advertising filter policy uses the white list and advertising is
        /// enabled. - the scanning filter policy uses the white list and scanning
        /// is enabled. - the initiator filter policy uses the white list and an
        /// LE_Create_Connection command is outstanding. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.8.15)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeClearWhiteList()
        {
            var status = new byte[1];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x010,
                ResponseParameter = status,
                ResponseLength = 1
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            return status[0] != 0 ? (BleStatus)status[0] : BleStatus.Success;
        }

        /// <summary>
        /// This command is used to add a single device
        /// to the white list stored in the Controller. This command can be used
        /// at any time except when: - the advertising filter policy uses the
        /// white list and advertising is enabled. - the scanning filter policy
        /// uses the white list and scanning is enabled. - the initiator filter
        /// policy uses the white list and a create connection command is
        /// outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.8.16)
        /// </summary>
        /// <param name="addressType">Address type.</param>
        /// <param name="address">Public Device Address or Random Device Address of the device
        /// to be added to the white list.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when address is null or not of length 6.</exception>
        public BleStatus LeAddDeviceToWhitelist(AddressType addressType, byte[] address)
        {
            if (address is null || address.Length != 6)
            {
                throw new ArgumentException();
            }

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)addressType;
            ptr += 1;
            address.CopyTo(command, ptr);
            ptr += 6;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x011,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to remove a
        /// single device from the white list stored in the Controller. This
        /// command can be used at any time except when: - the advertising filter
        /// policy uses the white list and advertising is enabled. - the scanning
        /// filter policy uses the white list and scanning is enabled. - the
        /// initiator filter policy uses the white list and a create connection
        /// command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2,
        /// Part E, 7.8.17)
        /// </summary>
        /// <param name="addressType">Address type.</param>
        /// <param name="address">Public Device Address or Random Device Address of the device
        /// to be removed from the white list.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException"></exception>
        public BleStatus LeRemoveDeviceFromWhitelist(AddressType addressType, byte[] address)
        {
            if (address is null || address.Length != 6)
            {
                throw new ArgumentException();
            }

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)addressType;
            ptr += 1;
            address.CopyTo(command, ptr);
            ptr += 6;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x012,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to change the Link Layer
        /// connection parameters of a connection. This command is supported only
        /// on master side. The Conn_Interval_Min and Conn_Interval_Max parameters
        /// are used to define the minimum and maximum allowed connection
        /// interval. The Conn_Interval_Min parameter shall not be greater than
        /// the Conn_Interval_Max parameter. The Conn_Latency parameter shall
        /// define the maximum allowed connection latency. The Supervision_Timeout
        /// parameter shall define the link supervision timeout for the LE link.
        /// The Supervision_Timeout in milliseconds shall be larger than (1 +
        /// Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is
        /// given in milliseconds. The Minimum_CE_Length and Maximum_CE_Length are
        /// information parameters providing the Controller with a hint about the
        /// expected minimum and maximum length of the connection events. The
        /// Minimum_CE_Length shall be less than or equal to the
        /// Maximum_CE_Length. The actual parameter values selected by the Link
        /// Layer may be different from the parameter values provided by the Host
        /// through this command. (See Bluetooth Specification v.4.1, Vol. 2, Part
        /// E, 7.8.18)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="minimumConnectionInterval">Minimum value for the connection event interval.
        /// This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25
        /// ms.</param>
        /// <param name="maximumConnectionInterval">Maximum value for the connection event interval.
        /// This shall be greater than or equal to Conn_Interval_Min. Time = N *
        /// 1.25 ms.</param>
        /// <param name="connectionLatency">Slave latency for the connection in number of connection
        /// events.</param>
        /// <param name="supervisionTimeout">Supervision timeout for the LE Link. It shall be a
        /// multiple of 10 ms and larger than (1 + connSlaveLatency) *
        /// connInterval * 2. Time = N * 10 ms.</param>
        /// <param name="minimumConnectionLength">Information parameter about the minimum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <param name="maximumConnectionLength">Information parameter about the maximum length of
        /// connection needed for this LE connection. Time = N * 0.625 ms.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeConnectionUpdate(
            ushort connectionHandle,
            ushort minimumConnectionInterval,
            ushort maximumConnectionInterval,
            ushort connectionLatency,
            ushort supervisionTimeout,
            ushort minimumConnectionLength,
            ushort maximumConnectionLength)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(minimumConnectionInterval).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(maximumConnectionInterval).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(connectionLatency).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(supervisionTimeout).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(minimumConnectionLength).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(maximumConnectionLength).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x013,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command allows the Host to
        /// specify a channel classification for data channels based on its "local
        /// information". This classification persists until overwritten with a
        /// subsequent LE_Set_Host_Channel_Classification command or until the
        /// Controller is reset using the Reset command (see [Vol 6] Part B,
        /// Section 4.5.8.1). If this command is used, the Host should send it
        /// within 10 seconds of knowing that the channel classification has
        /// changed. The interval between two successive commands sent shall be at
        /// least one second. This command shall only be used when the local
        /// device supports the Master role. (See Bluetooth Specification v.4.1,
        /// Vol. 2, Part E, 7.8.19)
        /// </summary>
        /// <param name="channelMap">This parameter contains 37 1-bit fields. The nth such
        /// field (in the range 0 to 36) contains the value for the link layer
        /// channel index n. Channel n is bad = 0. Channel n is unknown = 1. The
        /// most significant bits are reserved and shall be set to 0. At least one
        /// channel shall be marked as unknown.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when <see cref="channelMap"/> is null or not of length 5.</exception>
        public BleStatus LeSetHostChannelClassification(byte[] channelMap)
        {
            if (channelMap is null || channelMap.Length != 5)
                throw new ArgumentException();

            int ptr = 0;
            var command = new byte[258];

            channelMap.CopyTo(command, ptr);
            ptr += 5;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x014,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Read_Channel_Map command returns the current Channel_Map for
        /// the specified Connection_Handle. The returned value indicates the
        /// state of the Channel_Map specified by the last transmitted or received
        /// Channel_Map (in a CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the
        /// specified Connection_Handle, regardless of whether the Master has
        /// received an acknowledgement. (See Bluetooth Specification v.4.1, Vol.
        /// 2, Part E, 7.8.20)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="channelMap">This parameter contains 37 1-bit fields. The nth
        /// such field (in the range 0 to 36) contains the value for the link
        /// layer channel index n. Channel n is unused = 0. Channel n is used
        /// = 1. The most significant bits are reserved and shall be set to 0.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="NotImplementedException"></exception>
        public BleStatus LeReadChannelMap(ushort connectionHandle, out byte[] channelMap)
        {
            channelMap = null;

            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x015,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            channelMap = new byte[5];
            Array.Copy(response, 1, channelMap, 0, 5);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command requests a list of the used LE features from the remote
        /// device. This command shall return a list of the used LE features. For
        /// details see [Vol 6] Part B, Section 4.6. This command may be issued on
        /// both the master and slave. (See Bluetooth Specification v.4.1, Vol. 2,
        /// Part E, 7.8.21)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadRemoteUsedFeatures(ushort connectionHandle)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x016,
                Event = 0x0F,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to request the Controller to encrypt
        /// the Plaintext_Data in the command using the Key given in the command
        /// and returns the Encrypted_Data to the Host. The AES-128 bit block
        /// cypher is defined in NIST Publication FIPS-197
        /// (http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf). (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.22)
        /// </summary>
        /// <param name="key">128 bit key for the encryption of the data given in the command.</param>
        /// <param name="plaintextData">128 bit data block that is requested to be encrypted.</param>
        /// <param name="encryptedData">128 bit encrypted data block.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown if <see cref="key"/> or <see cref="plaintextData"/> are null or not of length 16.</exception>
        public BleStatus LeEncrypt(byte[] key, byte[] plaintextData, out byte[] encryptedData)
        {
            encryptedData = null;

            if (key is null || key.Length != 16)
                throw new ArgumentException(nameof(key));
            if (plaintextData is null || plaintextData.Length != 16)
                throw new ArgumentException(nameof(plaintextData));

            int ptr = 0;
            var command = new byte[258];

            key.CopyTo(command, ptr);
            ptr += 16;
            plaintextData.CopyTo(command, ptr);
            ptr += 16;

            const uint responseLength = 17;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x017,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            encryptedData = new byte[16];
            Array.Copy(response, 1, encryptedData, 0, 16);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to request the Controller to generate 8
        /// octets of random data to be sent to the Host. The Random_Number shall
        /// be generated according to [Vol 2] Part H, Section 2 if the LE Feature
        /// (LL Encryption) is supported. (See Bluetooth Specification v.4.1, Vol.
        /// 2, Part E, 7.8.23)
        /// </summary>
        /// <param name="randomNumber">Random number</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeRandom(out ulong randomNumber)
        {
            randomNumber = 0;

            const uint responseLength = 9;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x018,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            randomNumber = BitConverter.ToUInt64(response, 1);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to authenticate the given
        /// encryption key associated with the remote device specified by the
        /// connection handle, and once authenticated will encrypt the connection.
        /// The parameters are as defined in [Vol 3] Part H, Section 2.4.4. If the
        /// connection is already encrypted then the Controller shall pause
        /// connection encryption before attempting to authenticate the given
        /// encryption key, and then re-encrypt the connection. While encryption
        /// is paused no user data shall be transmitted. On an authentication
        /// failure, the connection shall be automatically disconnected by the
        /// Link Layer. If this command succeeds, then the connection shall be
        /// encrypted. This command shall only be used when the local device's
        /// role is Master. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.8.24)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="randomNumber">64 bit random number.</param>
        /// <param name="encryptedDiversifier">16 bit encrypted diversifier.</param>
        /// <param name="longTermKey">128 bit long term key.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when <see cref="longTermKey"/> is null or not of length 16.</exception>
        public BleStatus LeStartEncryption(ushort connectionHandle, ulong randomNumber, ushort encryptedDiversifier, byte[] longTermKey)
        {
            if (longTermKey is null || longTermKey.Length != 16)
                throw new ArgumentException(nameof(longTermKey));

            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(randomNumber).CopyTo(command, ptr);
            ptr += 8;
            BitConverter.GetBytes(encryptedDiversifier).CopyTo(command, ptr);
            ptr += 2;
            longTermKey.CopyTo(command, ptr);
            ptr += 16;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x019,
                Event = 0x0F,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to reply to an LE
        /// Long Term Key Request event from the Controller, and specifies the
        /// Long_Term_Key parameter that shall be used for this Connection_Handle.
        /// The Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3.
        /// (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.25)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <param name="longTermKey">128 bit long term key.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when <see cref="longTermKey"/> is null or is not of length 16.</exception>
        public BleStatus LeLongTermKeyRequestReply(ushort connectionHandle, byte[] longTermKey)
        {
            if (longTermKey is null || longTermKey.Length != 16)
                throw new ArgumentException(nameof(longTermKey));

            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;
            longTermKey.CopyTo(command, ptr);
            ptr += 16;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01a,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to reply
        /// to an LE Long Term Key Request event from the Controller if the Host
        /// cannot provide a Long Term Key for this Connection_Handle. (See
        /// Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.26)
        /// </summary>
        /// <param name="connectionHandle">Connection handle that identifies the connection.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeLongTermKeyRequestedNegativeReply(ushort connectionHandle)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01b,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Read_Supported_States command reads the states and state
        /// combinations that the link layer supports. See [Vol 6] Part B, Section
        /// 1.1.1. LE_States is an 8-octet bit field. If a bit is set to 1 then
        /// this state or state combination is supported by the Controller.
        /// Multiple bits in LE_States may be set to 1 to indicate support for
        /// multiple state and state combinations. All the Advertising type with
        /// the Initiate State combinations shall be set only if the corresponding
        /// Advertising types and Master Role combination are set. All the
        /// Scanning types and the Initiate State combinations shall be set only
        /// if the corresponding Scanning types and Master Role combination are
        /// set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.27)
        /// </summary>
        /// <param name="states">State or state combination is supported by the
        /// Controller. See Core v4.1, Vol.2, part E, Ch. 7.8.27.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadSupportedStates(out ulong states)
        {
            states = 0;

            const uint responseLength = 9;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01c,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            states = BitConverter.ToUInt64(response, 1);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to start a test where the DUT receives test
        /// reference packets at a fixed interval. The tester generates the test
        /// reference packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.8.28)
        /// </summary>
        /// <param name="rxFrequency">N = (F - 2402) / 2.
        /// Frequency Range : 2402 MHz to 2480 MHz</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReceiverTest(byte rxFrequency)
        {
            int ptr = 0;
            var command = new byte[258];

            command[ptr] = rxFrequency;
            ptr += 1;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01d,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to start a test where the DUT generates test
        /// reference packets at a fixed interval. The Controller shall transmit
        /// at maximum power. An LE Controller supporting the LE_Transmitter_Test
        /// command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE
        /// Controller may support other values of Packet_Payload. (See Bluetooth
        /// Specification v.4.1, Vol. 2, Part E, 7.8.29)
        /// </summary>
        /// <param name="txFrequency"> N = (F - 2402) / 2
        /// Frequency Range : 2402 MHz to 2480 MHz</param>
        /// <param name="testDataLength">Length in bytes of payload data in each packet.
        /// Supported ranges:
        /// <list type="bullet">
        /// <item>(0x00,0x25): BlueNRG-1 and BlueNRG-2 with BLE stack version before 2.1;</item>
        /// <item>(0x00,0xFF): BlueNRG-2 with BLE stack version 2.1 or later, and extended packet length.</item>
        /// </list>
        /// </param>
        /// <param name="packetPayload">Type of packet payload.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeTransmitterTest(byte txFrequency, byte testDataLength, PacketPayloadType packetPayload)
        {
            int ptr = 0;
            var command = new byte[258];

            command[ptr] = txFrequency;
            ptr += 1;
            command[ptr] = testDataLength;
            ptr += 1;
            command[ptr] = (byte)packetPayload;
            ptr += 1;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01e,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to stop any test which is in progress. The
        /// <see cref="numberOfPackets"/> for a transmitter test shall be reported as 0x0000.
        /// The <see cref="numberOfPackets"/> is an unsigned number and contains the number of
        /// received packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E,
        /// 7.8.30)
        /// </summary>
        /// <param name="numberOfPackets">Number of packets received.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeTestEnd(out ushort numberOfPackets)
        {
            numberOfPackets = 0;

            const uint responseLength = 9;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x01f,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            numberOfPackets = BitConverter.ToUInt16(response, 1);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command allows the Host to suggest maximum
        /// transmission packet size and maximum packet transmission time
        /// (connMaxTxOctets and connMaxTxTime - see [Vol 6] Part B, Section
        /// 4.5.10) to be used for a given connection. The Controller may use
        /// smaller or larger values based on local information.
        /// </summary>
        /// <param name="connectionHandle"><see cref="connectionHandle"/> to be used to identify a
        /// connection.</param>
        /// <param name="transmissionOctets">Preferred maximum number of payload octets that the local
        /// Controller should include in a single Link Layer Data Channel PDU.
        /// Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF) Reserved for
        /// future use). Default: 27 bytes.</param>
        /// <param name="transmissionTime">Preferred maximum number of microseconds that the local
        /// Controller should use to transmit a single Link Layer Data Channel
        /// PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 - 0xFFFF Reserved
        /// for future use). Default: 328 bytes.</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetDataLength(ushort connectionHandle, ushort transmissionOctets, ushort transmissionTime)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(connectionHandle).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(transmissionOctets).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(transmissionTime).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x022,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command allows the Host to
        /// read the Host preferred values for the Controller maximum transmitted
        /// number of payload octets and maximum packet transmission time to be
        /// used for new connections (connInitialMaxTxOctets and
        /// connInitialMaxTxTime - see ([Vol 6] Part B, Section 4.5.10).
        /// </summary>
        /// <param name="suggestedMaximumTransmissionOctets">The Host suggested value for the Controller
        /// maximum transmitted number of payload octets to be used for new
        /// connections - connInitialMaxTxOctets. Range 0x001B-0x00FB (0x0000
        /// - 0x001A and 0x00FC - 0xFFFF Reserved for future use) Default:
        /// 0x001B</param>
        /// <param name="suggestedMaxTransmissionTime">The Host suggested value for the Controller
        /// maximum packet transmission time to be used for new connections -
        /// connInitialMaxTx-Time. Range 0x0148-0x0848 (0x0000 - 0x0147 and
        /// 0x0849 - 0xFFFF Reserved for future use) Default: 0x0148</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadSuggestedDefaultDataLength(out ushort suggestedMaximumTransmissionOctets, out ushort suggestedMaxTransmissionTime)
        {
            suggestedMaximumTransmissionOctets = 0;
            suggestedMaxTransmissionTime = 0;

            const uint responseLength = 5;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x023,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            suggestedMaximumTransmissionOctets = BitConverter.ToUInt16(response, 1);
            suggestedMaxTransmissionTime = BitConverter.ToUInt16(response, 3);

            return BleStatus.Success;
        }

        /// <summary>
        /// This command allows the Host to
        /// specify its preferred values for the Controller maximum transmission
        /// number of payload octets and maximum packet transmission time to be
        /// used for new connections (connInitialMaxTxOctets and
        /// connInitialMaxTxTime - see [Vol 6] Part B, Section 4.5.10). The
        /// Controller may use smaller or larger values based on local
        /// information.
        /// </summary>
        /// <param name="suggestedMaximumTransmissionOctets">The Host suggested value for the Controller
        /// maximum transmitted number of payload octets to be used for new
        /// connections - connInitialMaxTxOctets. Range 0x001B-0x00FB (0x0000 -
        /// 0x001A and 0x00FC - 0xFFFF Reserved for future use)</param>
        /// <param name="suggestedMaxTransmissionTime">The Host suggested value for the Controller maximum
        /// packet transmission time to be used for new connections -
        /// connInitialMaxTx-Time. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849
        /// - 0xFFFF Reserved for future use)</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeWriteSuggestedDefaultDataLength(ushort suggestedMaximumTransmissionOctets, ushort suggestedMaxTransmissionTime)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(suggestedMaximumTransmissionOctets).CopyTo(command, ptr);
            ptr += 2;
            BitConverter.GetBytes(suggestedMaxTransmissionTime).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x024,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to return the local
        /// P-256 public key from the Controller. The Controller shall generate a
        /// new P-256 public/private key pair upon receipt of this command. (See
        /// Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.36)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadLocalP256PublicKey()
        {
            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x025,
                Event = 0x0F,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to initiate generation of a
        /// Diffie- Hellman key in the Controller for use over the LE transport.
        /// This command takes the remote P-256 public key as input. The Diffie-
        /// Hellman key generation uses the private key generated by
        /// LE_Read_Local_P256_Public_Key command. (See Bluetooth Specification
        /// v.4.2, Vol. 2, Part E, 7.8.37)
        /// </summary>
        /// <param name="remoteP256PublicKey">The remote P-256 public key: X, Y format Octets
        /// 31-0: X co-ordinate Octets 63-32: Y co-ordinate Little Endian Format</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when <see cref="remoteP256PublicKey"/> is null or not of length 64.</exception>
        public BleStatus LeGenerateDhKey(byte[] remoteP256PublicKey)
        {
            if (remoteP256PublicKey is null || remoteP256PublicKey.Length != 64)
                throw new ArgumentException();

            int ptr = 0;
            var command = new byte[258];

            remoteP256PublicKey.CopyTo(command, ptr);
            ptr += 64;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x026,
                Event = 0x0F,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to add one device
        /// to the list of address translations used to resolve Resolvable Private
        /// Addresses in the Controller. This command cannot be used when address
        /// translation is enabled in the Controller and: - Advertising is enabled
        /// - Scanning is enabled - Create connection command is outstanding This
        /// command can be used at any time when address translation is disabled
        /// in the Controller. When a Controller cannot add a device to the
        /// resolving list because the list is full, it shall respond with error
        /// code 0x07 (Memory Capacity Exceeded). (See Bluetooth Specification
        /// v.4.2, Vol. 2, Part E, 7.8.38)
        /// </summary>
        /// <param name="peerIdentityAddressType">Identity address type.</param>
        /// <param name="peerIdentityAddress">Public or Random (static) Identity address of
        /// the peer device.</param>
        /// <param name="peerIrk">IRK of the peer device.</param>
        /// <param name="localIrk">IRK of the local device.</param>
        /// <returns>Value indicating success or error code.</returns>
        /// <exception cref="ArgumentException">Thrown when arrays are null or of incorrect lengths.</exception>
        public BleStatus LeAddDeviceToResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, byte[] peerIrk, byte[] localIrk)
        {
            if (peerIdentityAddress is null || peerIdentityAddress.Length != 6)
                throw new ArgumentException(nameof(peerIdentityAddress));
            if (peerIrk is null || peerIrk.Length != 16)
                throw new ArgumentException(nameof(peerIrk));
            if (localIrk is null || localIrk.Length != 16)
                throw new ArgumentException(nameof(localIrk));

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)peerIdentityAddressType;
            ptr += 1;
            peerIdentityAddress.CopyTo(command, ptr);
            ptr += 6;
            peerIrk.CopyTo(command, ptr);
            ptr += 16;
            localIrk.CopyTo(command, ptr);
            ptr += 16;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x027,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to remove one
        /// device from the list of address translations used to resolve
        /// Resolvable Private Addresses in the controller. This command cannot be
        /// used when address translation is enabled in the Controller and: -
        /// Advertising is enabled - Scanning is enabled - Create connection
        /// command is outstanding This command can be used at any time when
        /// address translation is disabled in the Controller. When a Controller
        /// cannot remove a device from the resolving list because it is not
        /// found, it shall respond with error code 0x02 (Unknown Connection
        /// Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E,
        /// 7.8.39)
        /// </summary>
        /// <param name="peerIdentityAddressType">Identity address type.</param>
        /// <param name="peerIdentityAddress">Public or Random (static) Identity address of
        /// the peer device</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeRemoveDeviceFromResolvingList(AddressType peerIdentityAddressType, byte[] peerIdentityAddress)
        {
            if (peerIdentityAddress is null || peerIdentityAddress.Length != 6)
                throw new ArgumentException(nameof(peerIdentityAddress));

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)peerIdentityAddressType;
            ptr += 1;
            peerIdentityAddress.CopyTo(command, ptr);
            ptr += 6;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x028,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to remove all devices from
        /// the list of address translations used to resolve Resolvable Private
        /// Addresses in the Controller. This command cannot be used when address
        /// translation is enabled in the Controller and: - Advertising is enabled
        /// - Scanning is enabled - Create connection command is outstanding This
        /// command can be used at any time when address translation is disabled
        /// in the Controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E,
        /// 7.8.40)
        /// </summary>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeClearResolvingList()
        {
            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x029,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Read_Resolving_List_Size command is used to read the total
        /// number of address translation entries in the resolving list that can
        /// be stored in the Controller. (See Bluetooth Specification v.4.2, Vol.
        /// 2, Part E, 7.8.41)
        /// </summary>
        /// <param name="resolvingListSize">Number of address translation entries in the resolving list</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadResolvingListSize(out byte resolvingListSize)
        {
            resolvingListSize = 0;

            const uint responseLength = 2;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02a,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            resolvingListSize = response[1];

            return BleStatus.Success;
        }

        /// <summary>
        /// This command is used to get the current
        /// peer Resolvable Private Address being used for the corresponding peer
        /// Public and Random (static) Identity Address. The peer's resolvable
        /// address being used may change after the command is called. This
        /// command can be used at any time. When a Controller cannot find a
        /// Resolvable Private Address associated with the Peer Identity Address,
        /// it shall respond with error code 0x02 (Unknown Connection Identifier).
        /// (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.42)
        /// </summary>
        /// <param name="peerIdentityAddressType">Identity address type.</param>
        /// <param name="peerIdentityAddress">Public or Random (static) Identity address of
        /// the peer device</param>
        /// <param name="peerResolvableAddress">Resolvable Private Address being used by
        /// the peer device</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadPeerResolvableAddress(AddressType peerIdentityAddressType, byte[] peerIdentityAddress, out byte[] peerResolvableAddress)
        {
            peerResolvableAddress = null;

            if (peerIdentityAddress is null || peerIdentityAddress.Length != 6)
                throw new ArgumentException(nameof(peerIdentityAddress));

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)peerIdentityAddressType;
            ptr += 1;
            peerIdentityAddress.CopyTo(command, ptr);
            ptr += 6;

            const uint responseLength = 7;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02b,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            peerResolvableAddress = new byte[6];
            Array.Copy(response, 1, peerResolvableAddress, 0, 6);

            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Read_Local_Resolvable_Address command is used to get the
        /// current local Resolvable Private Address being used for the
        /// corresponding peer Identity Address. The local's resolvable address
        /// being used may change after the command is called. This command can be
        /// used at any time. When a Controller cannot find a Resolvable Private
        /// Address associated with the Peer Identity Address, it shall respond
        /// with error code 0x02 (Unknown Connection Identifier). (See Bluetooth
        /// Specification v.4.2, Vol. 2, Part E, 7.8.43)
        /// </summary>
        /// <param name="peerIdentityAddressType">Identity address type.</param>
        /// <param name="peerIdentityAddress">Public or Random (static) Identity address of
        /// the peer device</param>
        /// <param name="localResolvableAddress">Resolvable Private Address being used by
        /// the local device</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadLocalResolvableAddress(
            AddressType peerIdentityAddressType,
            byte[] peerIdentityAddress,
            out byte[] localResolvableAddress)
        {
            localResolvableAddress = null;

            if (peerIdentityAddress is null || peerIdentityAddress.Length != 6)
                throw new ArgumentException(nameof(peerIdentityAddress));

            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)peerIdentityAddressType;
            ptr += 1;
            peerIdentityAddress.CopyTo(command, ptr);
            ptr += 6;

            const uint responseLength = 7;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02c,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            localResolvableAddress = new byte[6];
            Array.Copy(response, 1, localResolvableAddress, 0, 6);

            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Set_Address_Resolution_Enable command is used to enable
        /// resolution of Resolvable Private Addresses in the Controller. This
        /// causes the Controller to use the resolving list whenever the
        /// Controller receives a local or peer Resolvable Private Address. This
        /// command can be used at any time except when: - Advertising is enabled
        /// - Scanning is enabled - Create connection command is outstanding (See
        /// Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.44)
        /// </summary>
        /// <param name="enableAddressResolution">Enable/disable address resolution in the
        /// controller. 0x00: Address Resolution in controller disabled (default),
        /// 0x01: Address Resolution in controller enabled</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetAddressResolutionEnable(bool enableAddressResolution)
        {
            int ptr = 0;
            var command = new byte[258];

            command[ptr] = (byte)(enableAddressResolution ? 0x01 : 0x00);
            ptr += 1;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02d,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Set_Resolvable_Private_Address_Timeout command set the length
        /// of time the controller uses a Resolvable Private Address before a new
        /// resolvable private address is generated and starts being used. This
        /// timeout applies to all addresses generated by the controller. (See
        /// Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.45)
        /// </summary>
        /// <param name="rpaTimeout">RPA_Timeout measured in seconds. Range for N: 0x0001 -
        /// 0xA1B8 (1 sec - approximately 11.5 hours) Default: N= 0x0384 (900 secs
        /// or 15 minutes)</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeSetResolvablePrivateAddressTimeout(ushort rpaTimeout)
        {
            int ptr = 0;
            var command = new byte[258];

            BitConverter.GetBytes(rpaTimeout).CopyTo(command, ptr);
            ptr += 2;

            const uint responseLength = 1;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02e,
                CommandLength = (uint)ptr,
                CommandParameter = command,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];
            return BleStatus.Success;
        }

        /// <summary>
        /// The LE_Read_Maximum_Data_Length command allows the Host to read the
        /// Controller  maximum supported payload octets and packet duration times
        /// for transmission and reception (supportedMaxTxOctets and
        /// supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime, see
        /// [Vol 6] Part B, Section 4.5.10).
        /// </summary>
        /// <param name="supportedMaximumOctets">Maximum number of payload octets that the
        /// local Controller supports for transmission of a single Link Layer
        /// Data Channel PDU. Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC
        /// - 0xFFFF Reserved for future use)</param>
        /// <param name="supportedMaximumTransmissionTime">Maximum time, in microseconds, that the local
        /// Controller supports for transmission of a single Link Layer Data
        /// Channel PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 -
        /// 0xFFFF Reserved for future use)</param>
        /// <param name="supportedMaximumReceivingOctets">Maximum number of payload octets that the
        /// local Controller supports for reception of a single Link Layer
        /// Data Channel PDU. Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC
        /// - 0xFFFF Reserved for future use)</param>
        /// <param name="supportedMaxReceivingTime">Maximum time, in microseconds, that the local
        /// Controller supports for reception of a single Link Layer Data
        /// Channel PDU. Range 0x0148-0x0848 (0x0000 - 0x0147 and 0x0849 -
        /// 0xFFFF Reserved for future use)</param>
        /// <returns>Value indicating success or error code.</returns>
        public BleStatus LeReadMaximumDataLength(
            out ushort supportedMaximumOctets,
            out ushort supportedMaximumTransmissionTime,
            out ushort supportedMaximumReceivingOctets,
            out ushort supportedMaxReceivingTime)
        {
            supportedMaximumOctets = 0;
            supportedMaximumTransmissionTime = 0;
            supportedMaximumReceivingOctets = 0;
            supportedMaxReceivingTime = 0;

            const uint responseLength = 9;
            var response = new byte[responseLength];
            var rq = new Request
            {
                OpCodeGroup = 0x08,
                OpCodeCommand = 0x02f,
                ResponseParameter = response,
                ResponseLength = responseLength
            };
            if (_transportLayer.SendRequest(ref rq, false) < 0)
                return BleStatus.Timeout;
            if (response[0] != 0)
                return (BleStatus)response[0];

            var ptr = 1;
            supportedMaximumOctets = BitConverter.ToUInt16(response, ptr);
            ptr += 2;
            supportedMaximumTransmissionTime = BitConverter.ToUInt16(response, ptr);
            ptr += 2;
            supportedMaximumReceivingOctets = BitConverter.ToUInt16(response, ptr);
            ptr += 2;
            supportedMaxReceivingTime = BitConverter.ToUInt16(response, ptr);

            return BleStatus.Success;
        }

        internal void UserEventProcess()
        {
            _transportLayer.UserEventProcess();
        }
    }
}
